<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of jacobian_movement</title>
  <meta name="keywords" content="jacobian_movement">
  <meta name="description" content="JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">forward</a> &gt; jacobian_movement.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/forward&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>jacobian_movement
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function J = jacobian_movement(fwd_model, img) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and
 electrode movement variables in 3D EIT.
 Args:     fwd_model - the EIDORS object forward model
            img - the image background conductivity

 fwd_model.conductivity_jacobian - function to calculate conductivity
                                   Jacobian (defaults to jacobian_adjoint)

 Returns:          J - the Jacobian matrix [Jc, Jm]

 WARNING: THIS CODE IS EXPERIMENTAL AND GIVES PROBLEMS
 SEE: Camille Gomez-Laberge, Andy Adler
 Direct EIT Jacobian calculations for conductivity change
  and electrode movement,  Physiol. Meas., 29:S89-S99, 208</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../../eidors/models/mdl_normalize.html" class="code" title="function out = mdl_normalize(mdl, val)">mdl_normalize</a>	MDL_NORMALIZE Check or set the normalize_measurements flag on a model.</li><li><a href="../../../eidors/models/mk_coarse_fine_mapping.html" class="code" title="function [mapping, outside] = mk_coarse_fine_mapping(varargin)">mk_coarse_fine_mapping</a>	MK_COARSE_FINE_MAPPING: create a mapping matrix from coarse to fine FEM</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="../../../eidors/models/mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft,scale)">mk_library_model</a>	MK_LIBRARY_MODEL - extruded FEM models based on curves in SHAPE_LIBRARY</li><li><a href="../../../eidors/models/mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>	MK_STIM_PATTERNS: create an EIDORS stimulation pattern structure</li><li><a href="../../../eidors/models/select_imdl.html" class="code" title="function [inv_mdl,opt_out]= select_imdl( mdl, options )">select_imdl</a>	SELECT_IMDL: select pre-packaged inverse model features</li><li><a href="../../../eidors/models/shape_library.html" class="code" title="function out = shape_library(action, shape, varargin)">shape_library</a>	SHAPE_LIBRARY Common shapes for models</li><li><a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload for Matlab < R2020a / 9.8).</li><li><a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>	CALC_JACOBIAN: calculate jacobian from an inv_model</li><li><a href="../../../eidors/solvers/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>	CALC_SYSTEM_MAT: calculate FEM system matrix from fwd_model and image</li><li><a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>	FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</li><li><a href="jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>	JACOBIAN_ADJOINT: J= jacobian_adjoint( img )</li><li><a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>	JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and</li><li><a href="jacobian_movement_perturb.html" class="code" title="function J= jacobian_movement_perturb( fwd_model, img)">jacobian_movement_perturb</a>	JACOBIAN_MOVEMENT_PERTURB: J= jacobian_movement_perturb( img )</li><li><a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>	FWD_SOLVE: calculate data from a fwd_model object and an image</li><li><a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>	INV_SOLVE: calculate imag from an inv_model and data</li><li><a href="../../../eidors/solvers/inverse/prior_movement.html" class="code" title="function Reg= prior_movement( inv_model );">prior_movement</a>	PRIOR_MOVEMENT calculate image prior</li><li><a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/deprecated/calc_move_jacobian.html" class="code" title="function J = calc_move_jacobian(varargin)">calc_move_jacobian</a>	CALC_MOVE_JACOBIAN   Computes the Jacobian matrix for conductivity and</li><li><a href="../../../eidors/models/select_imdl.html" class="code" title="function [inv_mdl,opt_out]= select_imdl( mdl, options )">select_imdl</a>	SELECT_IMDL: select pre-packaged inverse model features</li><li><a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>	JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and</li><li><a href="jacobian_movement_2p5d_1st_order.html" class="code" title="function J = jacobian_movement_2p5d_1st_order( fwd_model, img)">jacobian_movement_2p5d_1st_order</a>	JACOBIAN_MOVEMENT_2P5D: J = jacobian_movement_2p5d_1st_order( img )</li><li><a href="../../../eidors/solvers/inverse/inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">inv_solve_core</a>	INV_SOLVE_CORE Solver using a generic iterative algorithm</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function Ce= connectivity_matrix( pp );</a></li><li><a href="#_sub2" class="code">function [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );</a></li><li><a href="#_sub3" class="code">function J= nodes_to_stim_jacobian( delV, fwd_model, pp )</a></li><li><a href="#_sub4" class="code">function Jc = calc_conductivity_jacobian(pp, fwd_model, img);</a></li><li><a href="#_sub5" class="code">function Jm = calc_movement_jacobian(pp, fwd_model, img)</a></li><li><a href="#_sub6" class="code">function delVm=  calc_delVm( elec_nodes_array, pp, fwd_model, img, colidx, Re_Ce, cond_Ce_Vc)</a></li><li><a href="#_sub7" class="code">function SS= calc_unconnected_system_mat( fwd_model, img)</a></li><li><a href="#_sub8" class="code">function do_unit_test;</a></li><li><a href="#_sub9" class="code">function unit_test_compare_approaches</a></li><li><a href="#_sub10" class="code">function unit_test_matrix_derivatives</a></li><li><a href="#_sub11" class="code">function unit_test_diff_jacobian_b2C_const_cond</a></li><li><a href="#_sub12" class="code">function unit_test_diff_jacobian_n3r2_const_cond</a></li><li><a href="#_sub13" class="code">function unit_test_diff_jacobian_b2C_rand_cond</a></li><li><a href="#_sub14" class="code">function unit_test_diff_jacobian_n3r2_rand_cond</a></li><li><a href="#_sub15" class="code">function unit_test_3d_inv_solve1</a></li><li><a href="#_sub16" class="code">function unit_test_3d_inv_solve2</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function J = jacobian_movement(fwd_model, img)</a>
0002 <span class="comment">% JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and</span>
0003 <span class="comment">% electrode movement variables in 3D EIT.</span>
0004 <span class="comment">% Args:     fwd_model - the EIDORS object forward model</span>
0005 <span class="comment">%            img - the image background conductivity</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% fwd_model.conductivity_jacobian - function to calculate conductivity</span>
0008 <span class="comment">%                                   Jacobian (defaults to jacobian_adjoint)</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% Returns:          J - the Jacobian matrix [Jc, Jm]</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% WARNING: THIS CODE IS EXPERIMENTAL AND GIVES PROBLEMS</span>
0013 <span class="comment">% SEE: Camille Gomez-Laberge, Andy Adler</span>
0014 <span class="comment">% Direct EIT Jacobian calculations for conductivity change</span>
0015 <span class="comment">%  and electrode movement,  Physiol. Meas., 29:S89-S99, 208</span>
0016 
0017 <span class="comment">% (C) 2007, Camille Gomez-Laberge and Andy Adler.</span>
0018 <span class="comment">%  License: GPL version 2 or version 3</span>
0019 <span class="comment">% $Id: jacobian_movement.m 7009 2024-11-26 14:03:17Z aadler $</span>
0020 
0021 <span class="keyword">if</span> ischar(fwd_model) &amp;&amp; strcmp(fwd_model,<span class="string">'UNIT_TEST'</span>); do_unit_test; <span class="keyword">return</span> ; <span class="keyword">end</span>
0022 
0023 <span class="keyword">if</span> nargin == 1
0024    img= fwd_model;
0025 <span class="keyword">elseif</span>  strcmp(getfield(warning(<span class="string">'query'</span>,<span class="string">'EIDORS:DeprecatedInterface'</span>),<span class="string">'state'</span>),<span class="string">'on'</span>)
0026    warning(<span class="string">'EIDORS:DeprecatedInterface'</span>, <span class="keyword">...</span>
0027       [<span class="string">'Calling JACOBIAN_MOVEMENT with two arguments is deprecated and will cause'</span> <span class="keyword">...</span>
0028        <span class="string">' an error in a future version. First argument ignored.'</span>]);
0029    warning off EIDORS:DeprecatedInterface
0030 
0031 <span class="keyword">end</span>
0032 fwd_model= img.fwd_model;
0033 
0034 
0035 <span class="comment">% System matrix and its parameters</span>
0036 pp = <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>( fwd_model, <span class="string">'skip_VOLUME'</span> );
0037 pp.dfact = factorial(pp.n_dims);
0038 pp.DEBUG = 0;
0039 <span class="keyword">if</span> pp.DEBUG
0040     pp.ss_mat = <a href="#_sub7" class="code" title="subfunction SS= calc_unconnected_system_mat( fwd_model, img)">calc_unconnected_system_mat</a>( fwd_model, img);
0041     pp.fwd_meas =<a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( fwd_model, img);
0042 <span class="keyword">end</span>
0043 
0044 <span class="comment">%Tensor product for conductivity matrix %MC 25/05/2012</span>
0045 I_nd=speye(pp.n_dims+1); 
0046 sigma_mat=spdiags(img.elem_data,0,pp.n_elem,pp.n_elem);
0047 pp.kron_cond=kron(sigma_mat,I_nd);
0048 
0049 pp.Ce= <a href="#_sub1" class="code" title="subfunction Ce= connectivity_matrix( pp );">connectivity_matrix</a>( pp );
0050 s_mat= <a href="../../../eidors/solvers/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>( img );
0051 [pp.Vc, pp.Re] = <a href="#_sub2" class="code" title="subfunction [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );">Vc_Re_matrices</a>( pp, fwd_model, s_mat.E );
0052 
0053 <span class="keyword">if</span> isfield(fwd_model,<span class="string">'conductivity_jacobian'</span>)
0054    img.fwd_model.jacobian = fwd_model.conductivity_jacobian;
0055    Jc= <a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>( img );
0056 <span class="keyword">else</span>
0057    img.fwd_model = <a href="../../../eidors/models/mdl_normalize.html" class="code" title="function out = mdl_normalize(mdl, val)">mdl_normalize</a>(fwd_model, 0); <span class="comment">% we normalize on our own</span>
0058    Jc = <a href="jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>(img);
0059 <span class="comment">%    Jc = calc_conductivity_jacobian(pp, fwd_model, img);</span>
0060 <span class="keyword">end</span>
0061 
0062 
0063 Jm = <a href="#_sub5" class="code" title="subfunction Jm = calc_movement_jacobian(pp, fwd_model, img)">calc_movement_jacobian</a>(pp, fwd_model, img);
0064 J=[Jc,Jm];
0065 
0066 <span class="keyword">if</span> pp.normalize
0067     data= <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( img );
0068     J= J ./ (data.meas(:)*ones(1,size(J,2)));
0069 <span class="keyword">end</span>
0070 
0071 
0072 
0073 <span class="comment">% Define the element connectivity matrix Ce</span>
0074 <a name="_sub1" href="#_subfunctions" class="code">function Ce= connectivity_matrix( pp );</a>
0075 lengthX = (pp.n_dims+1)*pp.n_elem;
0076 <span class="comment">%%%%%lengthY = pp.n_node; %MC 11/05/2012</span>
0077 lengthY=size(pp.N2E,2);
0078 Xidx = pp.ELEM(:);
0079 Yidx = ones(lengthX, 1);
0080 Ce = <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(1:lengthX, Xidx, Yidx, lengthX, lengthY);
0081 
0082 
0083 
0084 <span class="comment">% Calculate fwd_solution and Impedance mapper matrices</span>
0085 <a name="_sub2" href="#_subfunctions" class="code">function [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );</a>
0086 <span class="comment">% Define the stimulation matrix Vc for each node I, and pattern</span>
0087 <span class="comment">% Ground node is never excited; remove it from the index</span>
0088 <span class="comment">%%%%%%nodeidx = 1:pp.n_node; %MC 11/05/2012</span>
0089 assert(size(s_mat,1) == size(s_mat,2),<span class="string">'s_mat must be square'</span>);
0090 nodeidx = 1:size(s_mat,1);
0091 nodeidx( fwd_model.gnd_node ) = [];
0092 
0093 <span class="comment">% The stimulation matrix Vc is the voltage at each node (row) for a</span>
0094 <span class="comment">% stimulation (column)</span>
0095 Vc = zeros(pp.n_node, pp.n_stim);
0096 Vc(nodeidx, :) = s_mat(nodeidx, nodeidx) \ pp.QQ(nodeidx,:);
0097 
0098 <span class="comment">% Define the electrode resistance matrix Re</span>
0099 <span class="comment">% Calculate the resistance between electrodes (row) and all nodes (col)</span>
0100 <span class="comment">% N2E matrix maps each electrode to its node(s); we exclude GND</span>
0101 Re = zeros(pp.n_elec, pp.n_node);
0102 Re(:, nodeidx) = pp.N2E(:, nodeidx) / s_mat(nodeidx, nodeidx);
0103 
0104 <span class="comment">% FIXME: why do we calculate the negative??</span>
0105 Re = -Re;
0106 
0107 
0108 
0109 <span class="comment">% Calculate Meas jacobian from derivative on nodes</span>
0110 <span class="comment">% Input delVc</span>
0111 <span class="comment">% Ouput J</span>
0112 <a name="_sub3" href="#_subfunctions" class="code">function J= nodes_to_stim_jacobian( delV, fwd_model, pp )</a>
0113 
0114 sz_out= size(delV,3);
0115 <span class="comment">% Define the conductivity Jacobian Jc</span>
0116 J = zeros(pp.n_meas, sz_out);
0117 <span class="comment">% Calculate the Jacobian columns for each stimulation pattern</span>
0118 rowidx = 0;
0119 <span class="keyword">for</span> j = 1:pp.n_stim
0120     <span class="comment">% Get the measurement pattern for the stimulation pattern j</span>
0121     meas_pattern = fwd_model.stimulation(j).meas_pattern;
0122     n_measj = size(meas_pattern, 1);
0123     <span class="comment">% Extract the voltage sensitivity for electrode j</span>
0124     delVcj = reshape( delV(:,j,:), pp.n_elec, sz_out);
0125     <span class="comment">% Calculate sensitivity block for measurements during stimulation j</span>
0126     J(rowidx+(1:n_measj), :) = meas_pattern*delVcj;
0127     rowidx = rowidx+n_measj;
0128 <span class="keyword">end</span>
0129 
0130 
0131 
0132 <span class="comment">% CONDUCTIVITY JACOBIAN (Based on Andy Adler's 1996 algorithms)</span>
0133 <span class="comment">% Define the voltage sensitivity delVc on electrode I, for stimulation</span>
0134 <span class="comment">% pattern J, for a change in conductivity of element K as a 3D array</span>
0135 <a name="_sub4" href="#_subfunctions" class="code">function Jc = calc_conductivity_jacobian(pp, fwd_model, img);</a>
0136 delVc = zeros(pp.n_elec, pp.n_stim, pp.n_elem);
0137 <span class="comment">% Calculate the values for the voltage sensitivity for each element</span>
0138 <span class="keyword">for</span> k = 1:pp.n_elem
0139     <span class="keyword">if</span> ~mod(k,500)
0140         fprintf(<span class="string">'   JC: element # %d\n'</span>,k);
0141     <span class="keyword">end</span>
0142     <span class="comment">% Extract the coordinates of the element's four nodes</span>
0143     Ae = pp.NODE(:,pp.ELEM(:,k))';
0144     <span class="comment">% Augment Ae by adding a column of ones to invert</span>
0145     Ae = inv([ones(pp.n_dims+1,1), Ae]);
0146     <span class="comment">% Define Be as the matrix Ae with row 1 deleted</span>
0147     Be = Ae(2:pp.n_dims+1,:);
0148     <span class="comment">% Calculate the system submatrix subSe for the element i</span>
0149     <span class="comment">%%%%%subSe = 2*Be'*Be/pp.dfact/abs(det(Ae)); %MC 11/05/2012</span>
0150     subSe = Be'*Be/pp.dfact/abs(det(Ae)); 
0151     <span class="comment">% Select the same submatrix of Ce</span>
0152     subidx = (pp.n_dims+1)*(k-1)+1 : (pp.n_dims+1)*k;
0153     <span class="comment">% The system submatrix is given by the product</span>
0154     <span class="keyword">if</span> ~pp.DEBUG
0155         delVc(:,:,k) = pp.Re * pp.Ce(subidx,:)' * subSe * pp.Ce(subidx,:)<span class="keyword">...</span>
0156             * pp.Vc;
0157     <span class="keyword">else</span>
0158         sz= (pp.n_dims+1)*pp.n_elem;
0159         delSe = <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(sz,sz);
0160         se_idx= (pp.n_dims+1)*k+(-pp.n_dims : 0);
0161         delSe(se_idx, se_idx) = subSe;
0162 
0163         delVc(:,:,k) = pp.Re * pp.Ce' * delSe * pp.Ce * pp.Vc;
0164 
0165         <span class="keyword">if</span> mod(k,50) == 0
0166             delta=1e-6;
0167             img_delta = img;
0168             img_delta.elem_data(k) = img_delta.elem_data(k) + delta;
0169             ss_mat_delta= <a href="#_sub7" class="code" title="subfunction SS= calc_unconnected_system_mat( fwd_model, img)">calc_unconnected_system_mat</a>( fwd_model, img_delta);
0170             delSe_pert = (ss_mat_delta - pp.ss_mat) / delta;
0171 
0172             <span class="keyword">if</span> norm(delSe -delSe_pert ,1) &gt; 1e-6
0173                 <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'delSe calc wrong'</span>,1);
0174             <span class="keyword">end</span>
0175         <span class="keyword">end</span>
0176     <span class="keyword">end</span>
0177 
0178 <span class="keyword">end</span>
0179 Jc= <a href="#_sub3" class="code" title="subfunction J= nodes_to_stim_jacobian( delV, fwd_model, pp )">nodes_to_stim_jacobian</a>( delVc, fwd_model, pp );
0180 
0181 
0182 
0183 <span class="comment">% MOVEMENT JACOBIAN</span>
0184 <a name="_sub5" href="#_subfunctions" class="code">function Jm = calc_movement_jacobian(pp, fwd_model, img)</a>
0185 <span class="comment">% The movement Jacobian is defined for each coordinate Jm = [Jmx Jmy Jmz]</span>
0186 <span class="comment">% Define the voltage sensitivity delVm on electrode I, for stimulation</span>
0187 <span class="comment">% pattern J, for a movement of electrode K as a 3D array</span>
0188 delVm = zeros(pp.n_elec, pp.n_stim, pp.n_elec*pp.n_dims);
0189 
0190 <span class="comment">% Precalculate</span>
0191 Re_Ce      = pp.Re * pp.Ce';
0192 cond_Ce_Vc = pp.kron_cond * pp.Ce * pp.Vc;
0193 <span class="keyword">for</span> colidx = 1:pp.n_dims
0194 <span class="comment">%    fprintf('   JM: direction # %d\n',colidx);</span>
0195     <span class="comment">% Calculate the values for the voltage sensitivity for each electrode</span>
0196     <span class="keyword">for</span> k = 1:pp.n_elec
0197         <span class="comment">% Find which elements touch this electrode</span>
0198         elec_nodes = fwd_model.electrode(k).nodes;
0199  
0200         <span class="comment">%for compound electrodes, average jacobian for each node</span>
0201 <span class="comment">%         delVm_part = zeros(pp.n_elec,pp.n_stim);</span>
0202         delVm_part = <a href="#_sub6" class="code" title="subfunction delVm=  calc_delVm( elec_nodes_array, pp, fwd_model, img, colidx, Re_Ce, cond_Ce_Vc)">calc_delVm</a>(elec_nodes(:)',pp,fwd_model,img,colidx,<span class="keyword">...</span>
0203                 Re_Ce, cond_Ce_Vc);
0204 <span class="comment">%         delVm_part = sparse(length(pp.kron_cond),length(pp.kron_cond));</span>
0205 <span class="comment">%         for each_elec_node= elec_nodes(:)';</span>
0206 <span class="comment">%            delVm_part =  delVm_part + ...</span>
0207 <span class="comment">%                 calc_delVm(each_elec_node,pp,fwd_model,img,colidx,...</span>
0208 <span class="comment">%                 Re_Ce, cond_Ce_Vc);</span>
0209 <span class="comment">%         end</span>
0210 <span class="comment">%         delVm_part = Re_Ce * delVm_part * cond_Ce_Vc;</span>
0211         <span class="comment">%%%%% delVm_part = delVm_part/length(elec_nodes); %MC 25/05/2012</span>
0212 <span class="comment">%         delVm_part = delVm_part;</span>
0213 
0214         vm_idx= k + pp.n_elec*(colidx-1);
0215         delVm(:,:,vm_idx) = delVm_part;
0216 
0217         <span class="keyword">if</span> pp.DEBUG
0218             delta=1e-8;
0219             mdl_delta = fwd_model;
0220             mdl_delta.nodes(elec_nodes, colidx) = <span class="keyword">...</span>
0221                 mdl_delta.nodes(elec_nodes, colidx) + delta;
0222             img_delta = img;
0223             img_delta.fwd_model = mdl_delta;
0224             S= <a href="../../../eidors/solvers/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>(img_delta); 
0225             S=S.E;
0226 <span class="comment">% FIXME: AA+CG 30/1/12</span>
0227             [Vc_delta] = <a href="#_sub2" class="code" title="subfunction [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );">Vc_Re_matrices</a>( pp, mdl_delta, S);
0228             delVm_pert = pp.N2E*(Vc_delta - pp.Vc) / delta;
0229             nn = norm(delVm_part - delVm_pert,1 ); <span class="comment">% WHY NEGATIVE?</span>
0230 
0231             <span class="comment">%%%%% if nn &gt; 5e-5 ; keyboard; end %MC 25/05/2012</span>
0232             <span class="keyword">if</span> nn &gt; 5e-3 ; keyboard; <span class="keyword">end</span>
0233 
0234         <span class="keyword">end</span>
0235     <span class="keyword">end</span>
0236 <span class="keyword">end</span>
0237 Jm= <a href="#_sub3" class="code" title="subfunction J= nodes_to_stim_jacobian( delV, fwd_model, pp )">nodes_to_stim_jacobian</a>( delVm, fwd_model, pp );
0238 
0239 
0240 
0241 <a name="_sub6" href="#_subfunctions" class="code">function delVm=  calc_delVm( elec_nodes_array, pp, fwd_model, img, colidx, Re_Ce, cond_Ce_Vc)</a>
0242 I = []; J=[]; S= [];
0243 <span class="keyword">for</span> elec_nodes= elec_nodes_array(:)';
0244 [rowidx, elemidx] = find(pp.ELEM == elec_nodes);
0245 <span class="comment">% Define the system sensitivity matrix to movement delSm</span>
0246 sz= (pp.n_dims+1)*pp.n_elem;
0247 <span class="comment">%delSm = sparse(sz,sz);</span>
0248 <span class="comment">% For each touching element, calculate the perturbation</span>
0249 jcount = 1;
0250 <span class="keyword">for</span> j = elemidx'
0251     <span class="comment">% Extract the coordinates of the element's four nodes</span>
0252     Ae = pp.NODE(:,pp.ELEM(:, j))';
0253     <span class="comment">% Define the invertible matrix P: augment Ae by adding a</span>
0254     <span class="comment">% column of ones to invert</span>
0255     P = [ones(pp.n_dims+1,1), Ae];
0256     Ae = inv(P);
0257     absdetAe = abs(det(Ae));
0258     <span class="comment">% Define Be as the matrix Ae with row 1 deleted</span>
0259     Be = Ae(2:pp.n_dims+1,:);
0260     <span class="comment">% For this coordinate, perturb P by [rowidx,colidx], which are</span>
0261     <span class="comment">% our paper's perturbation vectors [a,b]</span>
0262     a = zeros(pp.n_dims+1,1);
0263     b = a;
0264     a(rowidx(jcount)) = 1;
0265     jcount = jcount + 1;
0266     b(colidx+1) = 1;
0267     <span class="comment">% Calculate the system submatrix subSm for the element j by</span>
0268     <span class="comment">% asymmetric perturbation of the electrode node k</span>
0269     deldetAe =   1/absdetAe*b'*Ae*a;
0270     delBe = -Ae*a*b'*Ae;
0271     delBe = delBe(2:pp.n_dims+1,:);
0272     <span class="comment">%%%%%subSm = 2/pp.dfact*(...</span>
0273     <span class="comment">%%%%%    deldetAe*Be'*Be + ...</span>
0274     <span class="comment">%%%%%    delBe'*Be/absdetAe + ...</span>
0275     <span class="comment">%%%%%    Be'*delBe/absdetAe); %MC 11/05/2012</span>
0276     subSm = 1/pp.dfact*(<span class="keyword">...</span>
0277         deldetAe*Be'*Be + <span class="keyword">...</span>
0278         delBe'*Be/absdetAe + <span class="keyword">...</span>
0279         Be'*delBe/absdetAe);
0280 
0281     <span class="keyword">if</span> pp.DEBUG
0282         delta=1e-8;
0283         <span class="comment">%%%%% subSe = 2*Be'*Be/pp.dfact/abs(det(Ae)); %MC 25/05/2012</span>
0284         subSe = Be'*Be/pp.dfact/abs(det(Ae));
0285         d_NODE= pp.NODE;
0286         d_NODE(colidx,elec_nodes) =  d_NODE(colidx,elec_nodes) + delta;
0287         Ae = d_NODE(:,pp.ELEM(:, j))';
0288         Ae = inv( [ones(pp.n_dims+1,1), Ae] );
0289         absdetAe_pert = abs(det(Ae));
0290         deldetAe_pert = (absdetAe_pert - absdetAe) / delta;
0291         <span class="comment">% Define Be as the matrix Ae with row 1 deleted</span>
0292         Be = Ae(2:pp.n_dims+1,:);
0293         <span class="comment">%%%%% subSe_delta = 2*Be'*Be/pp.dfact/abs(det(Ae)); %MC 25/05/2012</span>
0294         subSe_delta = Be'*Be/pp.dfact/abs(det(Ae));
0295         subSm_pert= (subSe_delta - subSe ) / delta;
0296         <span class="keyword">if</span> norm(subSm_pert - subSm,1) &gt; 1e-5
0297             <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'subSm calc wrong'</span>,1);
0298             dd= (subSm_pert - 2/pp.dfact/absdetAe *<span class="keyword">...</span>
0299                 (delBe'*Be + Be'*delBe) )./(Be'*Be);
0300 
0301             fprintf(<span class="string">'colidx=%d, j=%d std=%6.4f &gt;'</span>,<span class="keyword">...</span>
0302                 colidx,j, std(dd(:)));
0303             keyboard
0304             subSm= subSm_pert;
0305         <span class="keyword">end</span>
0306     <span class="keyword">end</span>
0307 
0308     <span class="comment">% Embed subSm into delSm such that subSm(1,1) is the</span>
0309     <span class="comment">% (4j+1,4j+1) element of delSm</span>
0310     se_idx= (pp.n_dims+1)*j+(-pp.n_dims : 0);
0311     <span class="keyword">switch</span> pp.n_dims
0312        <span class="keyword">case</span> 2
0313           Iidx = vertcat(se_idx,se_idx,se_idx);
0314           I = [I Iidx(:)];
0315           J = [J, se_idx,se_idx,se_idx];
0316           
0317        <span class="keyword">case</span> 3
0318           Iidx = vertcat(se_idx,se_idx,se_idx,se_idx);
0319           I = [I Iidx(:)];
0320           J = [J, se_idx,se_idx,se_idx,se_idx];
0321     <span class="keyword">end</span>
0322     S = [S subSm(:)];
0323 <span class="comment">%     delSm(se_idx, se_idx) = subSm;</span>
0324 <span class="keyword">end</span>
0325 <span class="keyword">end</span>
0326 delSm = <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(I,J,S,sz,sz);
0327 delVm = Re_Ce * delSm * cond_Ce_Vc;
0328 
0329 
0330 <span class="comment">% The system submatrix is given by the product where delSm is</span>
0331 <span class="comment">% non-zero only in submatrices corresponding to touching elements</span>
0332 <span class="comment">%%%%% delVm = pp.Re * pp.Ce' * delSm * pp.Ce * pp.Vc; %MC 25/05/2012</span>
0333 <span class="comment">% delVm = Re_Ce * delSm * cond_Ce_Vc;</span>
0334 <span class="keyword">if</span> pp.DEBUG
0335     delta=1e-8;
0336     mdl_delta = fwd_model;
0337     mdl_delta.nodes(elec_nodes, colidx) = <span class="keyword">...</span>
0338         mdl_delta.nodes(elec_nodes, colidx) + delta;
0339     ss_mat_delta= <a href="#_sub7" class="code" title="subfunction SS= calc_unconnected_system_mat( fwd_model, img)">calc_unconnected_system_mat</a>( mdl_delta, img );
0340      delSm_pert = (ss_mat_delta - pp.ss_mat) / delta;
0341     <span class="comment">% delSe_pert shound be Ce'*delSe*Ce</span>
0342     <span class="keyword">if</span> norm(delSm -delSm_pert ,1) &gt; 1e-5
0343         <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'delSm calc wrong'</span>,1);
0344         <span class="comment">%%%%% delVm = pp.Re * pp.Ce' * delSm_pert * pp.Ce * pp.Vc; %MC 25/05/2012</span>
0345         delVm = pp.Re * pp.Ce' * delSm_pert * pp.kron_cond * pp.Ce * pp.Vc;
0346     
0347         keyboard
0348     <span class="keyword">end</span>
0349 <span class="keyword">end</span>
0350 
0351 
0352 
0353 <a name="_sub7" href="#_subfunctions" class="code">function SS= calc_unconnected_system_mat( fwd_model, img)</a>
0354 <span class="comment">% Calc system matrix for Andy Adler's EIT code</span>
0355 <span class="comment">% fwd_model = forward model</span>
0356 <span class="comment">% img       = image background for system matrix calc</span>
0357 <span class="comment">% s_mat = CC' * SS * conductivites * CC;</span>
0358 <span class="comment">% where:</span>
0359 <span class="comment">%   SS  = Unconnected system Matrix</span>
0360 <span class="comment">%   CC  = Connectivity Matrix</span>
0361 
0362 p= <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>( fwd_model, <span class="string">'skip_VOLUME'</span> );
0363 
0364 d= p.n_dims+1;
0365 e= p.n_elem;
0366 n= p.n_node;
0367 
0368 SSiidx= floor([0:d*e-1]'/d)*d*ones(1,d) + ones(d*e,1)*(1:d) ;
0369 SSjidx= [1:d*e]'*ones(1,d);
0370 SSdata= zeros(d*e,d);
0371 dfact= (d-1)*(d-2); <span class="comment">% Valid for d&lt;=3</span>
0372 <span class="keyword">for</span> j=1:e
0373     a=  inv([ ones(d,1), p.NODE( :, p.ELEM(:,j) )' ]);
0374     idx= d*(j-1)+1 : d*j;
0375     SSdata(idx,1:d)= a(2:d,:)'*a(2:d,:)/dfact/abs(det(a));
0376 
0377 <span class="keyword">end</span> <span class="comment">%for j=1:ELEMs</span>
0378 idx= 1:e*d;
0379 SS= <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(SSiidx,SSjidx,SSdata) * <span class="keyword">...</span>
0380     <a href="../../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(idx,idx, img.elem_data(ceil(idx/d)) );
0381 
0382 
0383 <a name="_sub8" href="#_subfunctions" class="code">function do_unit_test;</a>
0384    <a href="#_sub9" class="code" title="subfunction unit_test_compare_approaches">unit_test_compare_approaches</a>
0385    <a href="#_sub10" class="code" title="subfunction unit_test_matrix_derivatives">unit_test_matrix_derivatives</a>
0386    <a href="#_sub11" class="code" title="subfunction unit_test_diff_jacobian_b2C_const_cond">unit_test_diff_jacobian_b2C_const_cond</a>
0387    <a href="#_sub12" class="code" title="subfunction unit_test_diff_jacobian_n3r2_const_cond">unit_test_diff_jacobian_n3r2_const_cond</a>
0388    <a href="#_sub13" class="code" title="subfunction unit_test_diff_jacobian_b2C_rand_cond">unit_test_diff_jacobian_b2C_rand_cond</a>
0389    <a href="#_sub14" class="code" title="subfunction unit_test_diff_jacobian_n3r2_rand_cond">unit_test_diff_jacobian_n3r2_rand_cond</a>
0390   <a href="#_sub15" class="code" title="subfunction unit_test_3d_inv_solve1">unit_test_3d_inv_solve1</a>
0391   <a href="#_sub16" class="code" title="subfunction unit_test_3d_inv_solve2">unit_test_3d_inv_solve2</a>
0392    
0393 <a name="_sub9" href="#_subfunctions" class="code">function unit_test_compare_approaches</a>
0394    inv_model = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'d2t2'</span>,16);
0395    img  = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( inv_model);
0396    fwd_model = inv_model.fwd_model;
0397 
0398    pp = <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>( fwd_model );
0399    pp.DEBUG = 0;
0400    pp.dfact = factorial(pp.n_dims);
0401    s_mat= <a href="../../../eidors/solvers/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>(img );
0402    [pp.Vc, pp.Re] = <a href="#_sub2" class="code" title="subfunction [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );">Vc_Re_matrices</a>( pp, fwd_model, s_mat.E );
0403    pp.Ce= <a href="#_sub1" class="code" title="subfunction Ce= connectivity_matrix( pp );">connectivity_matrix</a>( pp );
0404 
0405    Jc1= <a href="#_sub4" class="code" title="subfunction Jc = calc_conductivity_jacobian(pp, fwd_model, img);">calc_conductivity_jacobian</a>(pp, fwd_model, img);
0406    Jc2= <a href="jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>(fwd_model,img);
0407    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Compare J d2t2'</span>, Jc1, Jc2, 1e-13);
0408 
0409    fwd_model.normalize_measurements = 1;
0410    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Compare J norm'</span>, Jc1, Jc2, 1e-13);
0411 
0412 
0413 
0414 <span class="comment">% TEST CODE FOR MATRIX DERIVATIVES</span>
0415 <a name="_sub10" href="#_subfunctions" class="code">function unit_test_matrix_derivatives</a>
0416 
0417 TEST= <span class="string">'d/dt det(X + t*a*b'')'</span>;
0418 d= 1e-8;
0419 X= rand(5);
0420 a=zeros(5,1); a(ceil(5*rand))=1;
0421 b=zeros(5,1); b(ceil(5*rand))=1;
0422 dX_p= (det(X + d*a*b') - det(X) )/d;
0423 dX  = b'*inv(X)*a*det(X);
0424 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(TEST, dX_p,dX,1e-6);
0425 
0426 TEST= <span class="string">'d/dt inv(X + t*a*b'')'</span>;
0427 dX_p= (inv(X + d*a*b') - inv(X) )/d;
0428 dX  = -inv(X)*a*b'*inv(X);
0429 <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(TEST, dX_p,dX,1e-5);
0430 
0431 <span class="comment">% TEST d/dt 1/abs(det(X + t*a*b')) = abs(1/det(X+t*a*b'))</span>
0432 <span class="keyword">for</span> i=1:10
0433     TEST = sprintf(<span class="string">'d/dt abs(1/det(X+t*a*b'')) [%02d]'</span>,i);
0434     X= rand(5);
0435     a=zeros(5,1); a(ceil(5*rand))=1;
0436     b=zeros(5,1); b(ceil(5*rand))=1;
0437     dX_p= (1/abs(det(X + d*a*b')) - 1/abs(det(X)) )/d;
0438     dX  = - 1/abs(det(X))*b'*inv(X)*a;
0439     <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(TEST, norm([dX_p-dX]),0, 1e-5*norm(dX));
0440 <span class="keyword">end</span>
0441 
0442 
0443    
0444 <a name="_sub11" href="#_subfunctions" class="code">function unit_test_diff_jacobian_b2C_const_cond</a>
0445    TEST= <span class="string">'J_perturb-J_direct - b2C model (const sigma)'</span>;
0446    mdl3dim = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>( <span class="string">'b2C'</span> );
0447    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl3dim);
0448    J_pert=<a href="jacobian_movement_perturb.html" class="code" title="function J= jacobian_movement_perturb( fwd_model, img)">jacobian_movement_perturb</a>(img);
0449    J_direct =<a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>(img);
0450    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(TEST, norm([J_pert-J_direct]),0, 1e-5*norm(J_direct));
0451 
0452    
0453 <a name="_sub12" href="#_subfunctions" class="code">function unit_test_diff_jacobian_n3r2_const_cond</a>
0454    TEST= <span class="string">'J_perturb-J_direct - n3r2 model (const sigma)'</span>;
0455    mdl3dim = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>( <span class="string">'n3r2'</span>, [16,2] );
0456    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl3dim);
0457    J_pert=<a href="jacobian_movement_perturb.html" class="code" title="function J= jacobian_movement_perturb( fwd_model, img)">jacobian_movement_perturb</a>(img);
0458    J_direct =<a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>(img);
0459    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(TEST, norm([J_pert-J_direct]),0, 1e-5*norm(J_direct));
0460    
0461 <a name="_sub13" href="#_subfunctions" class="code">function unit_test_diff_jacobian_b2C_rand_cond</a>
0462    TEST= <span class="string">'J_perturb-J_direct - b2C model (rand sigma)'</span>;
0463    mdl3dim = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>( <span class="string">'b2C'</span> );
0464    cond=0.5+rand(size(mdl3dim.fwd_model.elems,1),1);
0465    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl3dim,cond);
0466    J_direct =<a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>(img);
0467    J_pert=<a href="jacobian_movement_perturb.html" class="code" title="function J= jacobian_movement_perturb( fwd_model, img)">jacobian_movement_perturb</a>(img);   
0468    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(TEST, norm([J_pert-J_direct]),0, 1e-5*norm(J_direct));
0469    
0470 <a name="_sub14" href="#_subfunctions" class="code">function unit_test_diff_jacobian_n3r2_rand_cond</a>
0471    TEST= <span class="string">'J_perturb-J_direct - n3r2 model (rand sigma)'</span>;
0472    mdl3dim = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>( <span class="string">'n3r2'</span>, [16,2] );
0473    cond=0.5+rand(size(mdl3dim.fwd_model.elems,1),1);
0474    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl3dim,cond);
0475    J_pert=<a href="jacobian_movement_perturb.html" class="code" title="function J= jacobian_movement_perturb( fwd_model, img)">jacobian_movement_perturb</a>(img);
0476    J_direct =<a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>(img);
0477    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(TEST, norm([J_pert-J_direct]),0, 1e-5*norm(J_direct));
0478   
0479 <a name="_sub15" href="#_subfunctions" class="code">function unit_test_3d_inv_solve1</a>
0480    mdl3dim = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>( <span class="string">'n3r2'</span>, [16,2] );
0481    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl3dim);
0482    vh = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( img );
0483    mdl3dim.fwd_model.jacobian = @<a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>;
0484 
0485    mdl3dim.RtR_prior = @<a href="../../../eidors/solvers/inverse/prior_movement.html" class="code" title="function Reg= prior_movement( inv_model );">prior_movement</a>;
0486 
0487    imgM = <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(mdl3dim, vh, vh);
0488 
0489  <a name="_sub16" href="#_subfunctions" class="code">function unit_test_3d_inv_solve2</a>
0490     fmdl = <a href="../../../eidors/models/mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft,scale)">mk_library_model</a>(<span class="string">'adult_male_16el_lungs'</span>);
0491     [fmdl.stimulation, fmdl.meas_select] = <span class="keyword">...</span>
0492        <a href="../../../eidors/models/mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>(16,1,[0,1],[0,1],{<span class="string">'no_meas_current'</span>}, 1);
0493     
0494     outline = <a href="../../../eidors/models/shape_library.html" class="code" title="function out = shape_library(action, shape, varargin)">shape_library</a>(<span class="string">'get'</span>,<span class="string">'adult_male'</span>,<span class="string">'boundary'</span>);
0495     
0496     minnode = min(fmdl.nodes);
0497     maxnode = max(fmdl.nodes);
0498     imgsz = [32 32];
0499     
0500     xgrid = linspace(minnode(1),maxnode(1),imgsz(1));
0501     ygrid = linspace(minnode(2),maxnode(2),imgsz(2));
0502     rmdl = <a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>([],xgrid,ygrid);
0503     
0504     <span class="comment">% remove pixels outside the model</span>
0505     x_avg = conv2(xgrid, [1,1]/2,<span class="string">'valid'</span>);
0506     y_avg = conv2(ygrid, [1,1]/2,<span class="string">'valid'</span>);
0507     [x,y] = ndgrid( x_avg, y_avg);
0508     inside = inpolygon(x(:),y(:),outline(:,1),outline(:,2));
0509     ff = find(~inside);
0510     
0511     rmdl.elems([2*ff, 2*ff-1],:)= [];
0512     rmdl.coarse2fine([2*ff, 2*ff-1],:)= [];
0513     rmdl.coarse2fine(:,ff)= [];
0514     rmdl.mk_coarse_fine_mapping.f2c_offset = [0 0 0.5];
0515     rmdl.mk_coarse_fine_mapping.z_depth = 0.25;
0516     
0517     
0518     <span class="comment">% calculate coarse2fine</span>
0519     fmdl.coarse2fine = <a href="../../../eidors/models/mk_coarse_fine_mapping.html" class="code" title="function [mapping, outside] = mk_coarse_fine_mapping(varargin)">mk_coarse_fine_mapping</a>(fmdl,rmdl);
0520     
0521     imdl = <a href="../../../eidors/models/select_imdl.html" class="code" title="function [inv_mdl,opt_out]= select_imdl( mdl, options )">select_imdl</a>( fmdl,{<span class="string">'Basic GN dif'</span>});
0522     imdl.rec_model = rmdl;
0523     
0524     img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl,1);
0525    vh = <a href="../../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>( img );
0526    imdl.prior_use_fwd_not_rec = 1;
0527    imdl.fwd_model.jacobian = @<a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>;
0528    imdl.RtR_prior = @<a href="../../../eidors/solvers/inverse/prior_movement.html" class="code" title="function Reg= prior_movement( inv_model );">prior_movement</a>;
0529    imgM = <a href="../../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vh, vh);
0530</pre></div>
<hr><address>Generated on Sun 29-Dec-2024 19:54:43 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>