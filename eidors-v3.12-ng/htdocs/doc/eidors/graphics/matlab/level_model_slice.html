<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of level_model_slice</title>
  <meta name="keywords" content="level_model_slice">
  <meta name="description" content="LEVEL_MODEL_SLICE - level 3D points for slicing at z=0">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="#">graphics</a> &gt; <a href="index.html">matlab</a> &gt; level_model_slice.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/graphics/matlab&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>level_model_slice
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>LEVEL_MODEL_SLICE - level 3D points for slicing at z=0</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [out, out2, out3, out4] = level_model_slice(varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">LEVEL_MODEL_SLICE - level 3D points for slicing at z=0
 
 XYZ = LEVEL_MODEL_SLICE(NODES, LEVEL)
 XYZ = LEVEL_MODEL_SLICE(NODES, LEVEL, SN)
 Transforms a list of 3D points such that level is a slice at z=0.
    NODES: n_nodes x 3 list of point coordinates 
    LEVEL: definition of the slice(s). Can be:
     - scalar: number of slices along the z axis ordered max to min
     - vector (N x 3): intercepts with the coordinate axis
     - struct:
       .centre (N x 3): centre point for transformation
        .normal_angle (1 x 4) [nx, ny, nz, theta]: normal vector and angle 
          of rotation around the axis defined by it (right hand rule).
         The model will be rotated such that the normal vector becomes 
         [0,0,1].         
        .rotation_matrix (3 x 3)
        An error is thrown if both normal_angle and rotation_matrix are present.
   SN     : slice number to use if level defines multiple slices (default: 1).
    XYZ     : NODES transformed such that level is a slice at z=0.

 MDL = LEVEL_MODEL_SLICE(MDL,__) 
 Modifies the nodes of an EIDORS fwd_model structure MDL. Can be used in
 place of NODES with every other syntax.

 {XYZ} = LEVEL_MODEL_SLICE(MDL, LEVEL, 'all') 
 {XYZ} = LEVEL_MODEL_SLICE(NODES, LEVEL, 'all') 
 Returns a cell array (one per slice) of transformed NODES (or MDL.nodes).

 N = LEVEL_MODEL_SLICE(LEVEL) returns the number of slices defined in LEVEL.

 [__, C, M] = LEVEL_MODEL_SLICE(NODES/MDL, __) returns the center C and 
 tranformation matrix M.

 [__, C, M, ifun] = LEVEL_MODEL_SLICE(NODES/MDL,__) also returns a function 
 for an inverse transformation.

 [C,M] = LEVEL_MODEL_SLICE(LEVEL, SN) (discouraged) returns the center C and
 transformation matrix M of slice SN (optional, default 1). An error is 
 thrown if level is scalar. Note that two outputs must always be requested for 
 this syntax.  

 [C,M] = LEVEL_MODEL_SLICE(NODES, LEVEL, SN) (discouraged) allows to obtain C
 and M when LEVEL is scalar. Note that two outputs must always be requested for
 this syntax.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="level_model_slice.html" class="code" title="function [out, out2, out3, out4] = level_model_slice(varargin)">level_model_slice</a>	LEVEL_MODEL_SLICE - level 3D points for slicing at z=0</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>	calc_slices (img, levels, clim  ) show slices at levels of an</li><li><a href="calc_voxels.html" class="code" title="function [V, rimg] = calc_voxels(img, opt, level)">calc_voxels</a>	CALC_VOXELS Calculate volumetric data from an image</li><li><a href="level_model_slice.html" class="code" title="function [out, out2, out3, out4] = level_model_slice(varargin)">level_model_slice</a>	LEVEL_MODEL_SLICE - level 3D points for slicing at z=0</li><li><a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype )">mdl_slice_mapper</a>	MDL_SLICE_MAPPER: map pixels to FEM elements or nodes</li><li><a href="mdl_slice_mesher.html" class="code" title="function [nimg out] = mdl_slice_mesher(fmdl,level,varargin)">mdl_slice_mesher</a>	MDL_SLICE_MESHER A slice of a 3D FEM as a 2D FEM</li><li><a href="../../../eidors/models/mk_pixel_slice.html" class="code" title="function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)">mk_pixel_slice</a>	MK_PIXEL_SLICE create a pixel model to reconstruct on</li><li><a href="../../../eidors/models/place_elec_on_surf.html" class="code" title="function mdl2 = place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh)">place_elec_on_surf</a>	PLACE_ELEC_ON_SURF Place electrodes on the surface of a model</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function N = get_number_of_slices(level)</a></li><li><a href="#_sub2" class="code">function [C,M] = matrix_from_level(varargin)</a></li><li><a href="#_sub3" class="code">function [C, M] = matrix_from_number(nodes, num_levels, sn)</a></li><li><a href="#_sub4" class="code">function [C, M] = matrix_from_intercept(level, sn)</a></li><li><a href="#_sub5" class="code">function [C, M] = matrix_from_struct(level, sn)</a></li><li><a href="#_sub6" class="code">function check_scalar_level(num_levels)</a></li><li><a href="#_sub7" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [out, out2, out3, out4] = level_model_slice(varargin)</a>
0002 <span class="comment">%LEVEL_MODEL_SLICE - level 3D points for slicing at z=0</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% XYZ = LEVEL_MODEL_SLICE(NODES, LEVEL)</span>
0005 <span class="comment">% XYZ = LEVEL_MODEL_SLICE(NODES, LEVEL, SN)</span>
0006 <span class="comment">% Transforms a list of 3D points such that level is a slice at z=0.</span>
0007 <span class="comment">%    NODES: n_nodes x 3 list of point coordinates</span>
0008 <span class="comment">%    LEVEL: definition of the slice(s). Can be:</span>
0009 <span class="comment">%     - scalar: number of slices along the z axis ordered max to min</span>
0010 <span class="comment">%     - vector (N x 3): intercepts with the coordinate axis</span>
0011 <span class="comment">%     - struct:</span>
0012 <span class="comment">%       .centre (N x 3): centre point for transformation</span>
0013 <span class="comment">%        .normal_angle (1 x 4) [nx, ny, nz, theta]: normal vector and angle</span>
0014 <span class="comment">%          of rotation around the axis defined by it (right hand rule).</span>
0015 <span class="comment">%         The model will be rotated such that the normal vector becomes</span>
0016 <span class="comment">%         [0,0,1].</span>
0017 <span class="comment">%        .rotation_matrix (3 x 3)</span>
0018 <span class="comment">%        An error is thrown if both normal_angle and rotation_matrix are present.</span>
0019 <span class="comment">%   SN     : slice number to use if level defines multiple slices (default: 1).</span>
0020 <span class="comment">%    XYZ     : NODES transformed such that level is a slice at z=0.</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% MDL = LEVEL_MODEL_SLICE(MDL,__)</span>
0023 <span class="comment">% Modifies the nodes of an EIDORS fwd_model structure MDL. Can be used in</span>
0024 <span class="comment">% place of NODES with every other syntax.</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% {XYZ} = LEVEL_MODEL_SLICE(MDL, LEVEL, 'all')</span>
0027 <span class="comment">% {XYZ} = LEVEL_MODEL_SLICE(NODES, LEVEL, 'all')</span>
0028 <span class="comment">% Returns a cell array (one per slice) of transformed NODES (or MDL.nodes).</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% N = LEVEL_MODEL_SLICE(LEVEL) returns the number of slices defined in LEVEL.</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% [__, C, M] = LEVEL_MODEL_SLICE(NODES/MDL, __) returns the center C and</span>
0033 <span class="comment">% tranformation matrix M.</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% [__, C, M, ifun] = LEVEL_MODEL_SLICE(NODES/MDL,__) also returns a function</span>
0036 <span class="comment">% for an inverse transformation.</span>
0037 <span class="comment">%</span>
0038 <span class="comment">% [C,M] = LEVEL_MODEL_SLICE(LEVEL, SN) (discouraged) returns the center C and</span>
0039 <span class="comment">% transformation matrix M of slice SN (optional, default 1). An error is</span>
0040 <span class="comment">% thrown if level is scalar. Note that two outputs must always be requested for</span>
0041 <span class="comment">% this syntax.</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% [C,M] = LEVEL_MODEL_SLICE(NODES, LEVEL, SN) (discouraged) allows to obtain C</span>
0044 <span class="comment">% and M when LEVEL is scalar. Note that two outputs must always be requested for</span>
0045 <span class="comment">% this syntax.</span>
0046 <span class="comment">%</span>
0047 
0048 
0049 <span class="comment">% (C) 2006-2022 Andy Adler and Bartek Grychtol</span>
0050 <span class="comment">% License: GPL version 2 or version 3</span>
0051 <span class="comment">% $Id: level_model_slice.m 7045 2024-11-30 21:10:50Z bgrychtol $</span>
0052 
0053 <span class="keyword">if</span> nargin==1 &amp;&amp; ischar(varargin{1}) &amp;&amp; strcmp(varargin{1}, <span class="string">'UNIT_TEST'</span>)
0054   <a href="#_sub7" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>
0055 <span class="keyword">end</span>
0056 
0057 <span class="keyword">if</span> nargin == 0 || isempty(varargin{1})
0058    error(<span class="string">'EIDORS:WrongInput'</span>, <span class="string">'level_model_slice requires non-empty input'</span>);
0059 <span class="keyword">end</span>
0060 
0061 <span class="keyword">if</span> nargout &lt;= 1 || nargout &gt;= 3
0062     <span class="keyword">if</span> nargin == 1
0063         <span class="comment">% N = LEVEL_MODEL_SLICE(LEVEL) returns the number of slices defined in LEVEL</span>
0064         out = <a href="#_sub1" class="code" title="subfunction N = get_number_of_slices(level)">get_number_of_slices</a>(varargin{1});
0065     <span class="keyword">else</span>
0066         <span class="comment">% XYZ = LEVEL_MODEL_SLICE(NODES, LEVEL)</span>
0067         <span class="comment">% XYZ = LEVEL_MODEL_SLICE(NODES, LEVEL, SN)</span>
0068         <span class="keyword">if</span> nargin == 3 &amp;&amp; ischar(varargin{3}) &amp;&amp; strcmp(varargin{3},<span class="string">'all'</span>)
0069            n_slices = <a href="#_sub1" class="code" title="subfunction N = get_number_of_slices(level)">get_number_of_slices</a>(varargin{2});
0070            <span class="keyword">if</span> isstruct(varargin{1}), varargin{1}=varargin{1}.nodes; <span class="keyword">end</span>
0071            <span class="keyword">for</span> i = n_slices:-1:1
0072               out(i,1) = cell(1);
0073               [out{i,1}, C(i,:), M] = <a href="level_model_slice.html" class="code" title="function [out, out2, out3, out4] = level_model_slice(varargin)">level_model_slice</a>(varargin{1},varargin{2}, i);
0074            <span class="keyword">end</span>
0075         <span class="keyword">else</span> <span class="comment">% nargin==3</span>
0076             [C, M] = <a href="#_sub2" class="code" title="subfunction [C,M] = matrix_from_level(varargin)">matrix_from_level</a>(varargin{:});
0077             SHIFT = [C(1), C(2), C(3)] * M';
0078             SHIFT(3) = 0;
0079             <span class="comment">% accept fwd_model as input</span>
0080             <span class="keyword">if</span> isstruct(varargin{1})
0081                out = varargin{1};
0082                <span class="comment">% (nodes - C) * M' + SHIFT</span>
0083                out.nodes = bsxfun(@plus, bsxfun(@minus, out.nodes, C ) * M', SHIFT);
0084             <span class="keyword">else</span>
0085                <span class="comment">% (nodes - C) * M' + SHIFT</span>
0086                out = bsxfun(@plus, bsxfun(@minus, varargin{1}, C ) * M', SHIFT);
0087             <span class="keyword">end</span>
0088             <span class="keyword">if</span> nargout &gt;= 3
0089                 out2 = C;
0090                 out3 = M;
0091             <span class="keyword">end</span>
0092             <span class="keyword">if</span> nargout == 4
0093                out4 = @(nodes) (nodes - SHIFT) / M' + C;
0094             <span class="keyword">end</span>
0095         <span class="keyword">end</span>
0096     <span class="keyword">end</span>
0097 <span class="keyword">elseif</span> nargout == 2
0098     <span class="keyword">if</span> nargin &lt; 3
0099         <span class="comment">% [C,M] = LEVEL_MODEL_SLICE(LEVEL)</span>
0100         <span class="comment">% [C,M] = LEVEL_MODEL_SLICE(LEVEL, SN)</span>
0101         [out, out2] = <a href="#_sub2" class="code" title="subfunction [C,M] = matrix_from_level(varargin)">matrix_from_level</a>(varargin{:});
0102     <span class="keyword">else</span>
0103         <span class="comment">% [C,M] = LEVEL_MODEL_SLICE(NODES, LEVEL, SN)</span>
0104         [out, out2] = <a href="#_sub3" class="code" title="subfunction [C, M] = matrix_from_number(nodes, num_levels, sn)">matrix_from_number</a>(varargin{:});
0105     <span class="keyword">end</span>
0106 <span class="keyword">end</span>
0107 
0108 <a name="_sub1" href="#_subfunctions" class="code">function N = get_number_of_slices(level)  </a>
0109     <span class="keyword">if</span> isnumeric(level) &amp;&amp; isscalar(level)
0110         <a href="#_sub6" class="code" title="subfunction check_scalar_level(num_levels)">check_scalar_level</a>(level);
0111       N = level;
0112     <span class="keyword">elseif</span> isnumeric(level)
0113         N = size(level,1);
0114     <span class="keyword">elseif</span> isstruct(level) &amp;&amp; isscalar(level)
0115         N = size(level.centre, 1);
0116     <span class="keyword">else</span>
0117         error(<span class="string">'level must be numeric or a scalar struct'</span>);
0118     <span class="keyword">end</span>
0119 
0120 <a name="_sub2" href="#_subfunctions" class="code">function [C,M] = matrix_from_level(varargin)</a>
0121     nodes = []; sn = 1;
0122     <span class="keyword">switch</span> nargin
0123         <span class="keyword">case</span> 3 <span class="comment">% nodes, level, sn</span>
0124             nodes = varargin{1}; level = varargin{2}; sn = varargin{3};
0125         <span class="keyword">case</span> 2 <span class="comment">% level &amp; sn or nodes &amp; level</span>
0126             <span class="keyword">if</span> isnumeric(varargin{2}) &amp;&amp; isscalar(varargin{2}) 
0127                 level = varargin{1}; sn = varargin{2};
0128             <span class="keyword">else</span>
0129                 nodes = varargin{1}; level = varargin{2};
0130             <span class="keyword">end</span>
0131         <span class="keyword">case</span> 1 <span class="comment">% level</span>
0132             level = varargin{1};
0133     <span class="keyword">end</span>
0134 
0135     <span class="keyword">if</span> isnumeric(level) &amp;&amp; isscalar(level)
0136         <span class="keyword">if</span> isempty(nodes)
0137             error(<span class="string">'Need nodes to calculate with scalar numeric level'</span>);
0138         <span class="keyword">else</span>
0139             [C, M] = <a href="#_sub3" class="code" title="subfunction [C, M] = matrix_from_number(nodes, num_levels, sn)">matrix_from_number</a>(nodes, level, sn);
0140         <span class="keyword">end</span>
0141     <span class="keyword">elseif</span> isnumeric(level)
0142         [C, M] = <a href="#_sub4" class="code" title="subfunction [C, M] = matrix_from_intercept(level, sn)">matrix_from_intercept</a>(level, sn);
0143     <span class="keyword">elseif</span> isstruct(level) &amp;&amp; isscalar(level)
0144         [C, M] = <a href="#_sub5" class="code" title="subfunction [C, M] = matrix_from_struct(level, sn)">matrix_from_struct</a>(level, sn);
0145     <span class="keyword">else</span>
0146         error(<span class="string">'level must be numeric or a scalar struct'</span>);
0147     <span class="keyword">end</span>
0148 
0149     
0150 <a name="_sub3" href="#_subfunctions" class="code">function [C, M] = matrix_from_number(nodes, num_levels, sn)</a>
0151     <a href="#_sub6" class="code" title="subfunction check_scalar_level(num_levels)">check_scalar_level</a>(num_levels);
0152     <span class="keyword">if</span> isstruct(nodes)
0153         nodes = nodes.nodes;
0154     <span class="keyword">end</span>
0155     M = diag([1,1,1]);
0156     
0157     zmax= max(nodes(:,3));
0158     zmin= min(nodes(:,3));
0159     levels = linspace(zmax,zmin, num_levels+2);
0160     levels = levels(2:end-1);
0161     
0162     C = (max(nodes) + min(nodes))/2;
0163     C(3) = levels(sn);
0164     
0165     
0166     
0167   
0168 <a name="_sub4" href="#_subfunctions" class="code">function [C, M] = matrix_from_intercept(level, sn)   </a>
0169    <span class="keyword">if</span> nargin &lt; 2
0170      sn = 1;
0171    <span class="keyword">end</span>
0172    level = level(sn, :);
0173    R = eye(3);
0174    <span class="keyword">if</span> length(level)==4
0175      theta = -level(4); <span class="comment">% we rotate the model, user thinks of the image</span>
0176      R = [cos(theta), -sin(theta), 0; sin(theta), cos(theta), 0; 0,0,1;];
0177    <span class="keyword">end</span>
0178    
0179    <span class="comment">% Infinities tend to cause issues -&gt; replace with realmax</span>
0180    <span class="comment">% Don't need to worry about the sign of the inf</span>
0181    level( isinf(level) | isnan(level) ) = realmax;
0182    level( level==0 ) =     1e-10; <span class="comment">%eps;</span>
0183 
0184    <span class="comment">% Step 1: Choose a centre point in the plane</span>
0185    <span class="comment">%  Weight the point by it's inv axis coords</span>
0186    invlev= 1./level;
0187    ctr= invlev / sum( invlev.^2 );
0188 
0189    <span class="comment">% Step 2: Choose basis vectors in the plane</span>
0190    <span class="comment">%  First is the axis furthest from ctr</span>
0191    [jnk, s_ax]= sort( - abs(level - ctr) );
0192    v1= [0,0,0]; v1(s_ax(1))= level(s_ax(1));
0193    v1= v1 - ctr;
0194    v1= v1 / norm(v1);
0195 
0196    <span class="comment">% Step 3: Get off-plane vector, by cross product</span>
0197    v2= [0,0,0]; v2(s_ax(2))= level(s_ax(2));
0198    v2= v2 - ctr;
0199    v2= v2 / norm(v2);
0200    v3= cross(v1,v2);
0201 
0202    <span class="comment">% Step 4: Get orthonormal basis. Replace v2</span>
0203    v2= cross(v1,v3);
0204 
0205    <span class="comment">% Step 5: Get bases to point in 'positive directions'</span>
0206    v1= v1 * (1-2*(sum(v1)&lt;0));
0207    v2= v2 * (1-2*(sum(v2)&lt;0));
0208    v3= v3 * (1-2*(sum(v3)&lt;0));
0209    
0210    C = ctr;
0211    M = R * [v1;v2;v3];
0212 <span class="comment">%   NODE= [v1;v2;v3] * (vtx' - ctr'*ones(1,nn) );</span>
0213   
0214     
0215 <a name="_sub5" href="#_subfunctions" class="code">function [C, M] = matrix_from_struct(level, sn)</a>
0216   <span class="keyword">if</span> nargin &lt; 2
0217     sn = 1;
0218   <span class="keyword">end</span>
0219   <span class="keyword">if</span> ~isfield(level,<span class="string">'centre'</span>)
0220       error(<span class="string">'Struct input ''level'' not understood.'</span>);
0221   <span class="keyword">end</span>
0222   ctr = level.centre;
0223   <span class="keyword">if</span> numel(ctr) == 3
0224       C = ctr; <span class="comment">% make row</span>
0225   <span class="keyword">elseif</span> size(ctr,2) == 3 &amp;&amp; size(ctr, 1) ~= 3
0226       C = ctr(:,sn);
0227   <span class="keyword">else</span>
0228       C = ctr(sn,:);
0229   <span class="keyword">end</span>
0230   C = C(:)'; <span class="comment">% make row</span>
0231   
0232   <span class="keyword">if</span> isfield(level, <span class="string">'rotation_matrix'</span>)
0233       M = level.rotation_matrix;
0234       <span class="keyword">return</span> <span class="comment">% no questions asked</span>
0235   <span class="keyword">end</span>
0236   
0237   <span class="keyword">if</span> isfield(level, <span class="string">'normal'</span>) &amp;&amp; ~isfield(level,<span class="string">'normal_angle'</span>)
0238       level.normal_angle = level.normal; <span class="comment">%quietly accept</span>
0239   <span class="keyword">end</span>
0240  
0241   <span class="keyword">if</span> ~isfield(level,<span class="string">'normal_angle'</span>)
0242       error(<span class="string">'Struct input ''level'' not understood.'</span>);
0243   <span class="keyword">end</span>
0244   
0245   A = level.normal_angle(1:3);
0246   normA = norm(A);
0247   <span class="keyword">if</span> normA == 0
0248     error(<span class="string">'Normal vector has zero norm'</span>)
0249   <span class="keyword">end</span>
0250   A = A(:) / normA; <span class="comment">% normalize and make column</span>
0251   B = [0,0,1]';
0252   R = eye(3);
0253   <span class="keyword">if</span> length(level.normal_angle) == 4
0254     theta = level.normal_angle(4);
0255     R = [cos(theta), -sin(theta), 0; sin(theta), cos(theta), 0; 0,0,1;];
0256   <span class="keyword">end</span>
0257    
0258   cross_AB = cross(A,B);
0259   <span class="keyword">if</span> norm(cross_AB) == 0 <span class="comment">% parallel vectors</span>
0260     <span class="keyword">if</span> A(3) &gt; 0
0261       M = R*eye(3);
0262     <span class="keyword">elseif</span> A(3) &lt; 0
0263       M = R*diag([1,-1,-1]);
0264     <span class="keyword">end</span>
0265     <span class="keyword">return</span>
0266   <span class="keyword">end</span>
0267   
0268   <span class="keyword">if</span> 0
0269       <span class="comment">% from https://math.stackexchange.com/questions/180418/</span>
0270       <span class="comment">% calculate-rotation-matrix-to-align-vector-a-to-vector-b-in-3d</span>
0271       <span class="comment">% works well, but leaves a rotation that's hard to control</span>
0272       dot_AB = A(3);
0273       ssc = @(v) [0 -v(3) v(2); v(3) 0 -v(1); -v(2) v(1) 0];
0274       M = eye(3) + ssc(cross_AB) + <span class="keyword">...</span>
0275           ssc(cross_AB)^2*(1-dot_AB)/(norm(cross_AB)^2);
0276   <span class="keyword">else</span>
0277       <span class="comment">% here we define a nice coordinate system on the plane, and then</span>
0278       <span class="comment">% transform it to become the identity (ie. invert).</span>
0279       
0280       <span class="comment">% project each coordinate axis on the plane</span>
0281       I = eye(3);
0282       <span class="keyword">for</span> i = 1:3
0283           proj(:,i) = I(:,i) - (dot(I(:,i),A) / normA^2) * A;
0284       <span class="keyword">end</span>
0285       norm_proj = vecnorm(proj);
0286       max_norm = max(norm_proj);
0287       
0288       <span class="comment">% choose what happens based on which projection is longest</span>
0289       M = zeros(3);
0290       M(:,3) = A;
0291       <span class="keyword">if</span> norm_proj(3) == max_norm
0292           <span class="comment">% projection of z becomes y</span>
0293           M(:,2) = proj(:,3);
0294           M(:,1) = cross(M(:,2),M(:,3));
0295       <span class="keyword">elseif</span> norm_proj(2) == max_norm
0296           <span class="comment">% projection of y becomes y</span>
0297           M(:,2) = proj(:,2);
0298           M(:,1) = cross(M(:,2),M(:,3));
0299       <span class="keyword">else</span>
0300           <span class="comment">% projection of x becomes x</span>
0301           M(:,1) = proj(:,1);
0302           M(:,2) = cross(M(:,3),M(:,1));
0303       <span class="keyword">end</span>
0304       M = inv(M);  
0305   <span class="keyword">end</span>
0306   M = R*M ;  
0307   
0308 
0309 <a name="_sub6" href="#_subfunctions" class="code">function check_scalar_level(num_levels)</a>
0310    <span class="keyword">if</span> num_levels &lt;= 0
0311       error(<span class="string">'EIDORS:WrongInput'</span>, <span class="string">'Number of levels must be greater than 0.'</span>)
0312    <span class="keyword">end</span>
0313 
0314   
0315 <a name="_sub7" href="#_subfunctions" class="code">function do_unit_test</a>
0316   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Scalar level'</span>, <a href="level_model_slice.html" class="code" title="function [out, out2, out3, out4] = level_model_slice(varargin)">level_model_slice</a>(5),5);
0317   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Vector level'</span>, <a href="level_model_slice.html" class="code" title="function [out, out2, out3, out4] = level_model_slice(varargin)">level_model_slice</a>([inf, inf, 3]),1);
0318   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Matrix level'</span>, <a href="level_model_slice.html" class="code" title="function [out, out2, out3, out4] = level_model_slice(varargin)">level_model_slice</a>([inf, inf, 3; inf, inf, 5]),2);
0319   LVL = [inf, inf, 3; inf, inf, 5];
0320   LVL(:,4) = rand(1,2);
0321   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Matrix level angle'</span>, <a href="level_model_slice.html" class="code" title="function [out, out2, out3, out4] = level_model_slice(varargin)">level_model_slice</a>(LVL),2);
0322   lvl.centre = [ 0,0,0];
0323   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Struct level'</span>, <a href="level_model_slice.html" class="code" title="function [out, out2, out3, out4] = level_model_slice(varargin)">level_model_slice</a>(lvl),1);
0324   lvl.centre(2,:) = [0,0,3];
0325   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Struct level'</span>, <a href="level_model_slice.html" class="code" title="function [out, out2, out3, out4] = level_model_slice(varargin)">level_model_slice</a>(lvl),2);
0326   lvl.normal_angle = rand(3,1)-.5;
0327   lvl.normal_angle = lvl.normal_angle / norm(lvl.normal_angle);
0328   lvl.normal_angle(4) = 2*pi * rand(1);
0329   [C, M] = <a href="level_model_slice.html" class="code" title="function [out, out2, out3, out4] = level_model_slice(varargin)">level_model_slice</a>(lvl);
0330   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Normal -&gt; Matrix'</span>, M*lvl.normal_angle(1:3),[0,0,1]', 5*eps);
0331   [C, M] = <a href="level_model_slice.html" class="code" title="function [out, out2, out3, out4] = level_model_slice(varargin)">level_model_slice</a>([inf 5 inf]);
0332   lvl.normal_angle = [0,0,-1];
0333   [C, M] = <a href="level_model_slice.html" class="code" title="function [out, out2, out3, out4] = level_model_slice(varargin)">level_model_slice</a>(lvl);
0334   <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Parallel normal'</span>, M,diag([1,-1,-1]));
0335   
0336   lvl.normal_angle = [0,0,0];
0337   <span class="keyword">try</span>
0338     [C, M] = <a href="level_model_slice.html" class="code" title="function [out, out2, out3, out4] = level_model_slice(varargin)">level_model_slice</a>(lvl);
0339     fprintf(<span class="string">'TEST: %20s = %4s \n'</span>,<span class="string">'Expect error'</span>, <span class="string">'Fail'</span>);  
0340   <span class="keyword">catch</span>
0341     fprintf(<span class="string">'TEST: %20s = %4s \n'</span>,<span class="string">'Expect error'</span>, <span class="string">'OK'</span>); 
0342   <span class="keyword">end</span>
0343   imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,[16,2]); fmdl = imdl.fwd_model;
0344   nodes = <a href="level_model_slice.html" class="code" title="function [out, out2, out3, out4] = level_model_slice(varargin)">level_model_slice</a>(fmdl,[inf, inf, 1; inf, inf, 2],1);</pre></div>
<hr><address>Generated on Sun 29-Dec-2024 19:54:43 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>