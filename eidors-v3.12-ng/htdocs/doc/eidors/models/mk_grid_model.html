<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mk_grid_model</title>
  <meta name="keywords" content="mk_grid_model">
  <meta name="description" content="MK_GRID_MODEL: Create reconstruction model on pixelated grid">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">models</a> &gt; mk_grid_model.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/models&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>mk_grid_model
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>MK_GRID_MODEL: Create reconstruction model on pixelated grid</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> MK_GRID_MODEL: Create reconstruction model on pixelated grid 
  [cmdl,coarse2fine]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);

 Outputs:
  cmdl - eidors reconstruction model (coarse model)
  coarse2fine - c2f mapping to put onto fmdl (specify [] to not use)

 Inputs:
  fmdl - fine model (forward model) to create coarse2fine mapping
  xvec - x edges
  yvec - y edges
  zvec - z edges (optional - to create 3D model)
  removefn(xyzc) - function which elements to remove, given xyzctr
  removefn = 'outside' =&gt; remove elements outside the fmdl
    e.g. removefn = @(xyz) vecnorm(xyz(:,1:2),2,2)&gt;1.0;

 if fmdl == [], then just create the grid model without c2f

 Example: for circular model
  grid= linspace(-2,2,20);     % x,y grid
  [gmdl]= mk_grid_model([],grid,grid,[], @(xyz) vecnorm(xyz,2,2)&gt;1);

 Example: for constructing an inverse model
  grid{1}= linspace(-2,2,20);     % x grid
  grid{2}= linspace(-0.5,+0.5,5); % y grid
  grid{3}= linspace(-2, 0,20);    % z grid
  imdl = select_imdl( fmdl, {'Basic GN dif'});
  [imdl.rec_model,imdl.fwd_model.coarse2fine]= mk_grid_model(fmdl,grid{:});

 See also <a href="mk_coarse_fine_mapping.html" class="code" title="function [mapping, outside] = mk_coarse_fine_mapping(varargin)">MK_COARSE_FINE_MAPPING</a>, <a href="mk_pixel_slice.html" class="code" title="function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)">MK_PIXEL_SLICE</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>	EIDORS_OBJ: maintains EIDORS internals</li><li><a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>	INTERP_MESH: calculate interpolation points onto mdl elements</li><li><a href="mdl_normalize.html" class="code" title="function out = mdl_normalize(mdl, val)">mdl_normalize</a>	MDL_NORMALIZE Check or set the normalize_measurements flag on a model.</li><li><a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>	MK_GRID_C2F - calculate a coarse2fine mapping for grid coarse models.</li><li><a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="num_nodes.html" class="code" title="function num = num_nodes( mdl );">num_nodes</a>	NUM_NODES: number of elemnts in a (fwd or inv model or image)</li><li><a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload for Matlab < R2020a / 9.8).</li><li><a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>	FWD_SOLVE: calculate data from a fwd_model object and an image</li><li><a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>	INV_SOLVE: calculate imag from an inv_model and data</li><li><a href="../../eidors/tools/eidors_default.html" class="code" title="function varargout = eidors_default(varargin)">eidors_default</a>	EIDORS_DEFAULT Default function handler.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/deprecated/np_fwd_solve.html" class="code" title="function data= np_fwd_solve( fwd_model, img)">np_fwd_solve</a>	NP_FWD_SOLVE: data= np_fwd_solve( fwd_model, img)</li><li><a href="../../eidors/graphics/matlab/calc_grid_points.html" class="code" title="function [val, c2f] = calc_grid_points(img, xpts, ypts, zpts)">calc_grid_points</a>	CALC_GRID_POINTS - image values at points in grid</li><li><a href="../../eidors/graphics/matlab/calc_voxels.html" class="code" title="function [V, rimg] = calc_voxels(img, opt, level)">calc_voxels</a>	CALC_VOXELS Calculate volumetric data from an image</li><li><a href="../../eidors/graphics/matlab/img_point_mapper.html" class="code" title="function val = img_point_mapper(img, pts, maptype )">img_point_mapper</a>	IMG_POINT_MAPPER - image values at points</li><li><a href="../../eidors/graphics/matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>	out_img = show_slices (img, levels ) show slices at levels of an</li><li><a href="../../eidors/interface/eidors_readimg.html" class="code" title="function img = eidors_readimg( fname, format )">eidors_readimg</a>	EIDORS readimg - read reconstructed image files from</li><li><a href="define_ROIs.html" class="code" title="function [ROIs, imgR, imdl] = define_ROIs(imdl, varargin)">define_ROIs</a>	DEFINE_ROIS: define ROI regions in image</li><li><a href="mk_analytic_c2f.html" class="code" title="function [mapping, outside] = mk_analytic_c2f( f_mdl, c_mdl, opt)">mk_analytic_c2f</a>	MK_ANALYTIC_C2F: create a mapping matrix from coarse to fine FEM</li><li><a href="mk_common_gridmdl.html" class="code" title="function inv_mdl= mk_common_gridmdl( str, RM)">mk_common_gridmdl</a>	MK_COMMON_MODEL: make EIT on reconstruction grids (GREIT)</li><li><a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>	MK_GRID_C2F - calculate a coarse2fine mapping for grid coarse models.</li><li><a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="mk_pixel_slice.html" class="code" title="function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)">mk_pixel_slice</a>	MK_PIXEL_SLICE create a pixel model to reconstruct on</li><li><a href="mk_tet_c2f.html" class="code" title="function [c2f] = mk_tet_c2f(fmdl, rmdl, opt)">mk_tet_c2f</a>	MK_TET_C2F - calculate a coarse2fine mapping for two tet-based models.</li><li><a href="mk_tri2tet_c2f.html" class="code" title="function c2f = mk_tri2tet_c2f(fmdl,rmdl, opt)">mk_tri2tet_c2f</a>	MK_TRI2TET_C2F - coarse2fine mapping between tri-based and tet-based models</li><li><a href="mk_voxel_volume.html" class="code" title="function [imdl, fmdl] = mk_voxel_volume(varargin)">mk_voxel_volume</a>	MK_VOXEL_VOLUME create a voxel model to reconstruct on</li><li><a href="../../eidors/solvers/calc_RtR_prior.html" class="code" title="function RtR_prior = calc_RtR_prior( inv_model )">calc_RtR_prior</a>	RtR = calc_RtR_prior( inv_model )</li><li><a href="../../eidors/solvers/forward/calc_transferimpedance.html" class="code" title="function transfimp = calc_transferimpedance( img)">calc_transferimpedance</a>	CALC_TRANSFERIMPEDANCE: Calculates transfer impedance matrix</li><li><a href="../../eidors/solvers/forward/fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>	FWD_SOLVE_1ST_ORDER: data= fwd_solve_1st_order( img)</li><li><a href="../../eidors/solvers/forward/jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>	JACOBIAN_ADJOINT: J= jacobian_adjoint( img )</li><li><a href="../../eidors/solvers/forward/jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>	JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and</li><li><a href="../../eidors/solvers/forward/system_mat_1st_order.html" class="code" title="function s_mat= system_mat_1st_order( fwd_model, img)">system_mat_1st_order</a>	SYSTEM_MAT_1ST_ORDER: SS= system_mat_1st_order( fwd_model, img)</li><li><a href="../../eidors/solvers/inverse/GREIT_desired_img_sigmoid.html" class="code" title="function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)">GREIT_desired_img_sigmoid</a>	GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT</li><li><a href="../../eidors/solvers/inverse/prior_gaussian_HPF.html" class="code" title="function Reg= prior_gaussian_HPF( fwd_model );">prior_gaussian_HPF</a>	PRIOR_GAUSSIAN_HPF calculate image prior</li><li><a href="../../eidors/tests/test_2d_resistor.html" class="code" title="function test_2d_resistor(opt)">test_2d_resistor</a>	Create 2D model of a cylindrical resistor</li><li><a href="../../eidors/tests/test_3d_resistor.html" class="code" title="function test_3d_resistor(opt)">test_3d_resistor</a>	Create 3D model of a Rectangular resistor</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function c2f= calc_c2f_2d( fmdl, xvec, yvec);</a></li><li><a href="#_sub2" class="code">function c2f= calc_c2f_3d( fmdl, xvec, yvec, zvec);</a></li><li><a href="#_sub3" class="code">function [cmdl,rmelems]= mk_2d_grid(xvec, yvec, removefn);</a></li><li><a href="#_sub4" class="code">function [cmdl,rmelems]= mk_3d_grid(xvec, yvec, zvec,removefn)</a></li><li><a href="#_sub5" class="code">function mdl = set_pixel_pos(mdl, xvec, yvec)</a></li><li><a href="#_sub6" class="code">function in_d_pts = calc_in_d_pts( d_pts, dvec);</a></li><li><a href="#_sub7" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);</a>
0002 <span class="comment">% MK_GRID_MODEL: Create reconstruction model on pixelated grid</span>
0003 <span class="comment">%  [cmdl,coarse2fine]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Outputs:</span>
0006 <span class="comment">%  cmdl - eidors reconstruction model (coarse model)</span>
0007 <span class="comment">%  coarse2fine - c2f mapping to put onto fmdl (specify [] to not use)</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% Inputs:</span>
0010 <span class="comment">%  fmdl - fine model (forward model) to create coarse2fine mapping</span>
0011 <span class="comment">%  xvec - x edges</span>
0012 <span class="comment">%  yvec - y edges</span>
0013 <span class="comment">%  zvec - z edges (optional - to create 3D model)</span>
0014 <span class="comment">%  removefn(xyzc) - function which elements to remove, given xyzctr</span>
0015 <span class="comment">%  removefn = 'outside' =&gt; remove elements outside the fmdl</span>
0016 <span class="comment">%    e.g. removefn = @(xyz) vecnorm(xyz(:,1:2),2,2)&gt;1.0;</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% if fmdl == [], then just create the grid model without c2f</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% Example: for circular model</span>
0021 <span class="comment">%  grid= linspace(-2,2,20);     % x,y grid</span>
0022 <span class="comment">%  [gmdl]= mk_grid_model([],grid,grid,[], @(xyz) vecnorm(xyz,2,2)&gt;1);</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% Example: for constructing an inverse model</span>
0025 <span class="comment">%  grid{1}= linspace(-2,2,20);     % x grid</span>
0026 <span class="comment">%  grid{2}= linspace(-0.5,+0.5,5); % y grid</span>
0027 <span class="comment">%  grid{3}= linspace(-2, 0,20);    % z grid</span>
0028 <span class="comment">%  imdl = select_imdl( fmdl, {'Basic GN dif'});</span>
0029 <span class="comment">%  [imdl.rec_model,imdl.fwd_model.coarse2fine]= mk_grid_model(fmdl,grid{:});</span>
0030 <span class="comment">%</span>
0031 <span class="comment">% See also MK_COARSE_FINE_MAPPING, MK_PIXEL_SLICE</span>
0032 
0033 <span class="comment">% ISSUES:</span>
0034 <span class="comment">%  Ensure that grids are defined from smallest to largest</span>
0035 
0036 <span class="comment">% (C) 2008 Andy Adler. License: GPL version 2 or version 3</span>
0037 <span class="comment">% $Id: mk_grid_model.m 7044 2024-11-30 15:53:22Z aadler $</span>
0038 
0039 <span class="keyword">if</span> ischar(fmdl) &amp;&amp; strcmp(fmdl,<span class="string">'UNIT_TEST'</span>); <a href="#_sub7" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0040 
0041 
0042 <span class="keyword">if</span> nargin&lt;5 <span class="comment">% removefn not provided</span>
0043    removefn = [];
0044 <span class="keyword">end</span>
0045 <span class="keyword">if</span> nargin == 3 || isempty(zvec)
0046    do3d= false;
0047 <span class="keyword">elseif</span> nargin &gt; 3
0048    do3d=true;
0049 <span class="keyword">else</span>
0050    error(<span class="string">'check nargin'</span>);
0051 <span class="keyword">end</span>
0052 
0053 <span class="keyword">if</span> ~do3d
0054    [cmdl,rmelems] = <a href="#_sub3" class="code" title="subfunction [cmdl,rmelems]= mk_2d_grid(xvec, yvec, removefn);">mk_2d_grid</a>(xvec,yvec,removefn);
0055 <span class="keyword">else</span>
0056    [cmdl,rmelems] = <a href="#_sub4" class="code" title="subfunction [cmdl,rmelems]= mk_3d_grid(xvec, yvec, zvec,removefn)">mk_3d_grid</a>(xvec,yvec,zvec,removefn);
0057 <span class="keyword">end</span>
0058 
0059 <span class="comment">% this had too many side effects</span>
0060 cmdl = <a href="#_sub5" class="code" title="subfunction mdl = set_pixel_pos(mdl, xvec, yvec)">set_pixel_pos</a>(cmdl,xvec,yvec);<span class="comment">% same for 2d and 3d</span>
0061 
0062 <span class="comment">% put in the centre (or near it)</span>
0063 ctr = ones(<a href="num_nodes.html" class="code" title="function num = num_nodes( mdl );">num_nodes</a>(cmdl),1)*mean(cmdl.nodes);
0064 dctr= sum( (cmdl.nodes - ctr).^2, 2);
0065 [jnk, c_idx] = min(dctr);
0066 cmdl.gnd_node = c_idx(1);
0067 
0068 <span class="keyword">if</span> ~isempty( fmdl)
0069     <span class="keyword">if</span> size(fmdl.nodes,2) == 2
0070         assert(~do3d);
0071         c2f= <a href="#_sub1" class="code" title="subfunction c2f= calc_c2f_2d( fmdl, xvec, yvec);">calc_c2f_2d</a>( fmdl, xvec, yvec);
0072         
0073     <span class="keyword">else</span>
0074         <span class="keyword">if</span> ~do3d
0075             <span class="comment">% here we could incorporate z_depth</span>
0076             zvec = [ min(fmdl.nodes(:,3)) - 1; max(fmdl.nodes(:,3))+1 ];
0077             tmp = <a href="#_sub4" class="code" title="subfunction [cmdl,rmelems]= mk_3d_grid(xvec, yvec, zvec,removefn)">mk_3d_grid</a>(xvec,yvec,zvec,removefn);
0078         <span class="keyword">else</span>
0079             tmp = cmdl;
0080         <span class="keyword">end</span>
0081         c2f = <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(fmdl,tmp);
0082     <span class="keyword">end</span>
0083 <span class="keyword">else</span>
0084     c2f = [];
0085 <span class="keyword">end</span>
0086 
0087 <span class="comment">% now remove elements outsize shape</span>
0088 <span class="keyword">if</span> ischar(rmelems{2}) &amp;&amp; strcmp(rmelems{2},<span class="string">'OUTSIDE'</span>)
0089    rmelems{2} = (sum(c2f,1) &lt; eps);
0090    rmelems{1} = logical(kron(rmelems{2}, true(1,rmelems{1})));
0091 <span class="keyword">end</span>
0092 <span class="keyword">if</span> ~isempty(rmelems{1})
0093    cmdl.elems( rmelems{1}, : ) = [];
0094    cmdl.coarse2fine( rmelems{1},     :      ) = [];
0095    cmdl.coarse2fine(    :      , rmelems{2} ) = [];
0096    <span class="keyword">if</span> ~isempty(c2f)
0097       c2f(:,rmelems{2}) = [];
0098    <span class="keyword">end</span>
0099 <span class="comment">%  cmdl.remover = rmelems; % debugging</span>
0100 <span class="keyword">end</span>
0101 
0102 cmdl.boundary = <a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>( cmdl.elems);
0103 
0104 cmdl = <a href="mdl_normalize.html" class="code" title="function out = mdl_normalize(mdl, val)">mdl_normalize</a>(cmdl, <span class="string">'default'</span>);
0105 cmdl.solve =      @<a href="../../eidors/tools/eidors_default.html" class="code" title="function varargout = eidors_default(varargin)">eidors_default</a>;
0106 cmdl.system_mat = @<a href="../../eidors/tools/eidors_default.html" class="code" title="function varargout = eidors_default(varargin)">eidors_default</a>;
0107 cmdl.jacobian   = @<a href="../../eidors/tools/eidors_default.html" class="code" title="function varargout = eidors_default(varargin)">eidors_default</a>;
0108 
0109 <span class="comment">% standard field order</span>
0110 cmdl = <a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'set'</span>, cmdl);
0111 
0112 <a name="_sub1" href="#_subfunctions" class="code">function c2f= calc_c2f_2d( fmdl, xvec, yvec);</a>
0113    nef= size( fmdl.elems,1);
0114    c2f= <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(nef,0);
0115    mdl_pts = <a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>( fmdl, 3);
0116    x_pts = squeeze(mdl_pts(:,1,:));
0117    y_pts = squeeze(mdl_pts(:,2,:));
0118    <span class="keyword">for</span> yi= 1:length(yvec)-1
0119          in_y_pts = y_pts &gt;= yvec(yi) &amp; y_pts &lt; yvec(yi+1);
0120       <span class="keyword">for</span> xi= 1:length(xvec)-1
0121           in_x_pts =  x_pts &gt;= xvec(xi) &amp; x_pts &lt; xvec(xi+1);
0122           in_pts = mean( in_y_pts &amp; in_x_pts , 2);
0123           c2f = [c2f,<a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(in_pts)];
0124       <span class="keyword">end</span>
0125    <span class="keyword">end</span>
0126 
0127 <span class="comment">% Old implementation, replaced by mk_grid_c2f</span>
0128 <a name="_sub2" href="#_subfunctions" class="code">function c2f= calc_c2f_3d( fmdl, xvec, yvec, zvec);</a>
0129 <span class="comment">%  c2f= mk_coarse_fine_mapping( fmdl, cmdl);</span>
0130    nef= size( fmdl.elems,1);
0131 <span class="comment">%  c2f= sparse(nef,0);</span>
0132    c2fiidx= [];
0133    c2fjidx= [];
0134    c2fdata= [];
0135    jidx= 0;
0136    mdl_pts = <a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>( fmdl, 3);
0137    x_pts = squeeze(mdl_pts(:,1,:));
0138    y_pts = squeeze(mdl_pts(:,2,:));
0139    z_pts = squeeze(mdl_pts(:,3,:));
0140    
0141    in_x_pts = <a href="#_sub6" class="code" title="subfunction in_d_pts = calc_in_d_pts( d_pts, dvec);">calc_in_d_pts</a>( x_pts, xvec);
0142    in_y_pts = <a href="#_sub6" class="code" title="subfunction in_d_pts = calc_in_d_pts( d_pts, dvec);">calc_in_d_pts</a>( y_pts, yvec);
0143    in_z_pts = <a href="#_sub6" class="code" title="subfunction in_d_pts = calc_in_d_pts( d_pts, dvec);">calc_in_d_pts</a>( z_pts, zvec);
0144 
0145    <span class="keyword">for</span> zi= 1:length(zvec)-1
0146       <span class="keyword">for</span> yi= 1:length(yvec)-1
0147              in_yz_pts = in_y_pts{yi} &amp; in_z_pts{zi};
0148          <span class="keyword">for</span> xi= 1:length(xvec)-1
0149              in_pts = mean( in_x_pts{xi} &amp; in_yz_pts, 2);
0150              <span class="comment">% c2f = [c2f,sparse(in_pts)];</span>
0151              [ii,jj,vv] = find(in_pts);
0152              c2fiidx= [c2fiidx;ii];
0153              c2fjidx= [c2fjidx;jj+jidx]; jidx=jidx+1;
0154              c2fdata= [c2fdata;vv];
0155          <span class="keyword">end</span>
0156       <span class="keyword">end</span>
0157    <span class="keyword">end</span>
0158    c2f= <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(c2fiidx,c2fjidx,c2fdata, length(in_pts), jidx);
0159 
0160 <a name="_sub3" href="#_subfunctions" class="code">function [cmdl,rmelems]= mk_2d_grid(xvec, yvec, removefn);</a>
0161    xlen = length(xvec);
0162    ylen = length(yvec);
0163    cmdl= <a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'fwd_model'</span>, <span class="keyword">...</span>
0164             sprintf(<span class="string">'Grid model %d x %d'</span>, xlen, ylen) );
0165 
0166    [x,y]= ndgrid( xvec, yvec);
0167    cmdl.nodes= [x(:),y(:)];
0168    k= 1:xlen-1;
0169    elem_frac = [ k;k+1;k+xlen; <span class="keyword">...</span>
0170                  k+1;k+xlen;k+xlen+1];
0171    elem_frac= reshape(elem_frac, 3,[])';
0172    cmdl.elems=  [];
0173    <span class="keyword">for</span> j=0:ylen-2
0174       cmdl.elems=  [cmdl.elems; elem_frac + xlen*j];
0175    <span class="keyword">end</span>
0176 
0177    <span class="keyword">if</span> isempty(removefn)
0178       rmelems{1} = [];
0179       rmelems{2} = [];
0180    <span class="keyword">elseif</span> ischar(removefn) &amp;&amp; strcmp(upper(removefn),<span class="string">'OUTSIDE'</span>) 
0181       rmelems{2} = <span class="string">'OUTSIDE'</span>; <span class="comment">% solve later</span>
0182       rmelems{1} = 2; <span class="comment">% divide factor</span>
0183    <span class="keyword">else</span> <span class="comment">% it's a function</span>
0184       <span class="comment">% Ensure we get centre of each grid square from triangles</span>
0185       xyzc = <a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(cmdl);
0186       xyzc = kron(xyzc(1:2:<span class="keyword">end</span>,:) + xyzc(2:2:<span class="keyword">end</span>,:),[1;1]/2);
0187       rmelems{1} = removefn(xyzc);
0188       rmelems{2} = rmelems{1}(1:2:end);
0189    <span class="keyword">end</span>
0190 
0191 <span class="comment">% assign one single parameter to each square element</span>
0192    e= size(cmdl.elems,1);
0193    params= ceil(( 1:e )/2);
0194    cmdl.coarse2fine = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(1:e,params,1,e,max(params));
0195 
0196    cmdl.boundary = <a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>( cmdl.elems);
0197 
0198 <a name="_sub4" href="#_subfunctions" class="code">function [cmdl,rmelems]= mk_3d_grid(xvec, yvec, zvec,removefn)</a>
0199    xlen = length(xvec);
0200    ylen = length(yvec);
0201    zlen = length(zvec);
0202    <span class="keyword">if</span> zlen&lt;2 || ylen&lt;2 || xlen&lt;2
0203       error(<span class="string">'Need at least 2 components for each gridpoint'</span>)
0204    <span class="keyword">end</span>
0205    cmdl= <a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'fwd_model'</span>, <span class="keyword">...</span>
0206             sprintf(<span class="string">'Grid model %d x %d x %d'</span>, xlen, ylen, zlen) );
0207 
0208    [x,y,z]= ndgrid( xvec, yvec, zvec);
0209    cmdl.nodes= [x(:),y(:),z(:)];
0210    k= 1:xlen-1;
0211    ac = xlen; up = xlen*ylen; <span class="comment">% accross vs up</span>
0212    elem_frac = [ k;     k+1 ;  k+ac;   k+up;  <span class="keyword">...</span>
0213                  k+1;   k+ac;  k+up;   k+up+1; <span class="keyword">...</span>
0214                  k+ac;  k+up;  k+up+1; k+up+ac; <span class="keyword">...</span>
0215                  k+1;   k+ac;  k+ac+1; k+up+1; <span class="keyword">...</span>
0216                  k+ac;  k+ac+1;k+up+1; k+up+ac; <span class="keyword">...</span>
0217                  k+ac+1;k+up+1;k+up+ac;k+up+ac+1];
0218    elem_frac= reshape(elem_frac, 4,[])';
0219    sz_elem_frac = size(elem_frac);
0220    row_frac =  zeros(sz_elem_frac .* [ylen-1,1]);
0221    <span class="keyword">for</span> j=0:ylen-2
0222       idx = (1:sz_elem_frac(1)) + j*sz_elem_frac(1);
0223       row_frac(idx,:)=  elem_frac + ac*j;
0224    <span class="keyword">end</span>
0225    
0226    sz_row_frac = size(row_frac);
0227    cmdl.elems=  zeros(sz_row_frac .* [zlen-1,1]);
0228    <span class="keyword">for</span> k=0:zlen-2
0229       idx = (1:sz_row_frac(1)) + k*sz_row_frac(1);
0230       cmdl.elems(idx,:) =  row_frac + up*k;
0231    <span class="keyword">end</span>
0232 
0233    <span class="keyword">if</span> isempty(removefn)
0234       rmelems{1} = [];
0235       rmelems{2} = [];
0236    <span class="keyword">elseif</span> ischar(removefn) &amp;&amp; strcmp(upper(removefn),<span class="string">'OUTSIDE'</span>) 
0237       rmelems{2} = <span class="string">'OUTSIDE'</span>; <span class="comment">% solve later</span>
0238       rmelems{1} = 6; <span class="comment">% divide factor</span>
0239    <span class="keyword">else</span> <span class="comment">% it's a function</span>
0240       <span class="comment">% Ensure we get centre of each grid square from triangles</span>
0241       xyzc = <a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(cmdl);
0242       xyzc = kron(xyzc(1:6:<span class="keyword">end</span>,:) + <span class="keyword">...</span>
0243                   xyzc(2:6:<span class="keyword">end</span>,:) + <span class="keyword">...</span>
0244                   xyzc(3:6:<span class="keyword">end</span>,:) + <span class="keyword">...</span>
0245                   xyzc(4:6:<span class="keyword">end</span>,:) + <span class="keyword">...</span>
0246                   xyzc(5:6:<span class="keyword">end</span>,:) + <span class="keyword">...</span>
0247                   xyzc(6:6:<span class="keyword">end</span>,:),[1;1;1;1;1;1]/6);
0248       rmelems{1} = removefn(xyzc);
0249       rmelems{2} = rmelems{1}(1:6:end);
0250    <span class="keyword">end</span>
0251 
0252 <span class="comment">% assign one single parameter to each square element</span>
0253    e= size(cmdl.elems,1);
0254    params= ceil(( 1:e )/6);
0255    cmdl.coarse2fine = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(1:e,params,1,e,max(params));
0256 
0257 <a name="_sub5" href="#_subfunctions" class="code">function mdl = set_pixel_pos(mdl, xvec, yvec)</a>
0258    x = xvec(1:end-1) + 0.5*diff(xvec);
0259    y = yvec(1:end-1) + 0.5*diff(yvec);
0260    y = y(end:-1:1); <span class="comment">%get the medical orientation right</span>
0261    mdl.mdl_slice_mapper.x_pts = x;
0262    mdl.mdl_slice_mapper.y_pts = y;
0263    
0264    
0265 <a name="_sub6" href="#_subfunctions" class="code">function in_d_pts = calc_in_d_pts( d_pts, dvec);</a>
0266    l1dvec= length(dvec)-1;
0267    in_d_pts = cell(l1dvec,1);
0268    <span class="keyword">for</span> i= 1:l1dvec
0269       in_d_pts{i} = d_pts &gt;= dvec(i) &amp; d_pts &lt; dvec(i+1);
0270    <span class="keyword">end</span>
0271 
0272 <a name="_sub7" href="#_subfunctions" class="code">function do_unit_test</a>
0273 imdl = <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'b2c2'</span>,16); imdl.hyperparameter.value = 1e-3;
0274 img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl,1);     vh= <a href="../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(img);
0275 img.elem_data([51,23])=1.1; vi= <a href="../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(img);
0276 subplot(3,4,1); <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img);
0277 subplot(3,4,2); <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(<a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vh, vi));
0278 
0279 grid = linspace(-1,1,33);
0280 [imdl.rec_model, imdl.fwd_model.coarse2fine] = <span class="keyword">...</span>
0281      <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>( imdl.fwd_model, grid, grid );
0282 subplot(3,4,3); <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(<a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vh, vi));
0283 hold on; hh=<a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img); set(hh,<span class="string">'FaceAlpha'</span>,0,<span class="string">'EdgeColor'</span>,[0,0,1]); hold off;
0284 
0285 <span class="keyword">if</span> 0
0286   outside = find(sum(imdl.fwd_model.coarse2fine,1) &lt; eps);
0287   imdl.fwd_model.coarse2fine(:,outside) = [];
0288   imdl.rec_model.coarse2fine(:,outside) = [];
0289   rec_out = [2*outside-1,2*outside];
0290   imdl.rec_model.coarse2fine(rec_out,:) = [];
0291   imdl.rec_model.elems(rec_out,:) = [];
0292 <span class="keyword">else</span>
0293   rmfn = <span class="string">'outside'</span>;
0294   [imdl.rec_model, imdl.fwd_model.coarse2fine] = <span class="keyword">...</span>
0295        <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>( imdl.fwd_model, grid, grid, [],rmfn );
0296 <span class="keyword">end</span>
0297 subplot(3,4,4); <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(<a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vh, vi));
0298 hold on; hh=<a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img); set(hh,<span class="string">'FaceAlpha'</span>,0,<span class="string">'EdgeColor'</span>,[0,0,1]); hold off;
0299 
0300 rmfn = @(xyz) vecnorm(xyz,2,2)&gt;1;
0301 [imdl.rec_model, imdl.fwd_model.coarse2fine] = <span class="keyword">...</span>
0302      <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>( imdl.fwd_model, grid, grid, [],rmfn );
0303 subplot(3,4,5); <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(<a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl, vh, vi));
0304 hold on; hh=<a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img); set(hh,<span class="string">'FaceAlpha'</span>,0,<span class="string">'EdgeColor'</span>,[0,0,1]); hold off;
0305 
0306 subplot(3,4,6)
0307 imdl = <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,[16,2]);
0308 A= [390 391 393 396 402 478 479 480 484 486 664 665 666 667 668 670 671 672 676 677 678 755 760 761];
0309 B= [318 319 321 324 330 439 440 441 445 447 592 593 594 595 596 598 599 600 604 605 606 716 721 722];
0310 img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl.fwd_model,1); vh = <a href="../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(img);
0311 img.elem_data(A)=1.5; img.elem_data(B)=0.5; vi=<a href="../../eidors/solvers/fwd_solve.html" class="code" title="function data = fwd_solve(fwd_model, img)">fwd_solve</a>(img);
0312 <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img);
0313 
0314 subplot(3,4,7)
0315 [cmdl, c2f]= <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>(img.fwd_model, -.8:.1:.8, -.8:.1:.8, 0:.5:3);
0316 v = c2f'*(img.elem_data-1) + 1;
0317 img2 = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(cmdl, v);
0318 <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img2)
0319 
0320 subplot(3,4,8)
0321 rmfn = @(xyz) vecnorm(xyz(:,1:2),2,2)&gt;1.0;
0322 [imdl.rec_model, imdl.fwd_model.coarse2fine] = <span class="keyword">...</span>
0323     <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>(img.fwd_model, -1:.1:1, -1:.1:1, 0:.5:3,rmfn );
0324 <span class="comment">%v = imdl.fwd_model.coarse2fine'*(img.elem_data-1)+1;</span>
0325 <span class="comment">%img2 = mk_image(imdl.rec_model, v);</span>
0326 img2= <a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl,vh,vi);
0327 <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img2)
0328 
0329 subplot(3,4,9)
0330 [imdl.rec_model, imdl.fwd_model.coarse2fine] = <span class="keyword">...</span>
0331     <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>(img.fwd_model, -1:.1:1, -1:.1:1, 0:.5:3,<span class="string">'outside'</span>);
0332 <span class="comment">%v = imdl.fwd_model.coarse2fine'*(img.elem_data-1)+1;</span>
0333 <span class="comment">%img2 = mk_image(imdl.rec_model, v);</span>
0334 img2= <a href="../../eidors/solvers/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl,vh,vi);
0335 <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img2)
0336 
0337 subplot(3,4,10)
0338    l48 = linspace(0.5,48.5,24+1); 
0339    l32 =-linspace(0.5,32.5,16+1) + 20; 
0340    rmfn = @(xyz) vecnorm(xyz,2,2)&gt;40;
0341    fmdl = <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>([],l48,l32,l48,rmfn);
0342 <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(fmdl)</pre></div>
<hr><address>Generated on Sun 29-Dec-2024 19:54:43 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>