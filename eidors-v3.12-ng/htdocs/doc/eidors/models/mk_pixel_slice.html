<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mk_pixel_slice</title>
  <meta name="keywords" content="mk_pixel_slice">
  <meta name="description" content="MK_PIXEL_SLICE create a pixel model to reconstruct on">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">models</a> &gt; mk_pixel_slice.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/models&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>mk_pixel_slice
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>MK_PIXEL_SLICE create a pixel model to reconstruct on</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [imdl fmdl] = mk_pixel_slice(imdl,level,opt) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">MK_PIXEL_SLICE create a pixel model to reconstruct on
 OUT = MK_PIXEL_SLICE(MDL, LEVEL, OPT) creates a slice of pixels as a
 model to reconstruct on. 

 Inputs:
  MDL   = an EIDORS forward or inverse model structure
  LEVEL = any definition accepted by LEVEL_MODEL_SLICE for a single slice
  OPT   = an option structure with the following fields and defaults:
     opt.imgsz = [32 32];    % dimensions of the pixel grid
     opt.square_pixels = 0;  % adjust imgsz to get square pixels
     opt.do_coarse2fine = 1; % calcuate c2f on the forward model
     opt.z_depth = inf;      % z_depth to use with mk_coarse_fine_mapping

 Output depends on the type of model suplied. If MDL is a fwd_model
 structure then OUT is a rec_model. If MDL is an inv_model, then OUT is a
 modified version of it, with the pixel slice in inv_model.rec_model and
 updated inv_model.fwd_model.coarse2fine
 
 [OUT FMDL] = MK_PIXEL_SLICE(MDL, ...) also returns the forward model
 structure with the coarse2fine field.

 See also <a href="mk_coarse_fine_mapping.html" class="code" title="function [mapping, outside] = mk_coarse_fine_mapping(varargin)">MK_COARSE_FINE_MAPPING</a>, <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">MK_GRID_MODEL</a>, LEVEL_MODEL_SLICE</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>	EIDORS_OBJ: maintains EIDORS internals</li><li><a href="../../eidors/graphics/matlab/calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>	calc_slices (img, levels, clim  ) show slices at levels of an</li><li><a href="../../eidors/graphics/matlab/level_model_slice.html" class="code" title="function [out, out2, out3, out4] = level_model_slice(varargin)">level_model_slice</a>	LEVEL_MODEL_SLICE - level 3D points for slicing at z=0</li><li><a href="../../eidors/graphics/matlab/mdl_slice_mesher.html" class="code" title="function [nimg out] = mdl_slice_mesher(fmdl,level,varargin)">mdl_slice_mesher</a>	MDL_SLICE_MESHER A slice of a 3D FEM as a 2D FEM</li><li><a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../eidors/graphics/matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>	out_img = show_slices (img, levels ) show slices at levels of an</li><li><a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft,scale)">mk_library_model</a>	MK_LIBRARY_MODEL - extruded FEM models based on curves in SHAPE_LIBRARY</li><li><a href="mk_pixel_slice.html" class="code" title="function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)">mk_pixel_slice</a>	MK_PIXEL_SLICE create a pixel model to reconstruct on</li><li><a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>	POINT_IN_TRIANGLE tests points for membership in triangles</li><li><a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="map_RM_slice.html" class="code" title="function imdl = map_RM_slice(imdl,varargin)">map_RM_slice</a>	map_RM_slice - map a 3D reconstruction matrix to an arbitrary 2D slice</li><li><a href="mk_GN_model.html" class="code" title="function imdl = mk_GN_model(img, opt, lambda)">mk_GN_model</a>	MK_GN_MODEL: make EIDORS inverse models using the GREIT approach</li><li><a href="mk_GREIT_model.html" class="code" title="function [imdl, weight]= mk_GREIT_model( fmdl, radius, weight, options )">mk_GREIT_model</a>	MK_GREIT_MODEL: make EIDORS inverse models using the GREIT approach</li><li><a href="mk_pixel_slice.html" class="code" title="function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)">mk_pixel_slice</a>	MK_PIXEL_SLICE create a pixel model to reconstruct on</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [rmdl fmdl] = do_pixel_slice(fmdl, opt);</a></li><li><a href="#_sub2" class="code">function mat_idx = calc_mat_idx(rmdl,fmdl,ff,opt)</a></li><li><a href="#_sub3" class="code">function opt = parse_opts(fmdl, opt)</a></li><li><a href="#_sub4" class="code">function elec_lev = get_elec_level(fmdl)</a></li><li><a href="#_sub5" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)</a>
0002 <span class="comment">%MK_PIXEL_SLICE create a pixel model to reconstruct on</span>
0003 <span class="comment">% OUT = MK_PIXEL_SLICE(MDL, LEVEL, OPT) creates a slice of pixels as a</span>
0004 <span class="comment">% model to reconstruct on.</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% Inputs:</span>
0007 <span class="comment">%  MDL   = an EIDORS forward or inverse model structure</span>
0008 <span class="comment">%  LEVEL = any definition accepted by LEVEL_MODEL_SLICE for a single slice</span>
0009 <span class="comment">%  OPT   = an option structure with the following fields and defaults:</span>
0010 <span class="comment">%     opt.imgsz = [32 32];    % dimensions of the pixel grid</span>
0011 <span class="comment">%     opt.square_pixels = 0;  % adjust imgsz to get square pixels</span>
0012 <span class="comment">%     opt.do_coarse2fine = 1; % calcuate c2f on the forward model</span>
0013 <span class="comment">%     opt.z_depth = inf;      % z_depth to use with mk_coarse_fine_mapping</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% Output depends on the type of model suplied. If MDL is a fwd_model</span>
0016 <span class="comment">% structure then OUT is a rec_model. If MDL is an inv_model, then OUT is a</span>
0017 <span class="comment">% modified version of it, with the pixel slice in inv_model.rec_model and</span>
0018 <span class="comment">% updated inv_model.fwd_model.coarse2fine</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% [OUT FMDL] = MK_PIXEL_SLICE(MDL, ...) also returns the forward model</span>
0021 <span class="comment">% structure with the coarse2fine field.</span>
0022 <span class="comment">%</span>
0023 <span class="comment">% See also MK_COARSE_FINE_MAPPING, MK_GRID_MODEL, LEVEL_MODEL_SLICE</span>
0024 
0025 <span class="comment">% (C) 2013 Bartlomiej Grychtol. License: GPL version 2 or 3</span>
0026 <span class="comment">% $Id: mk_pixel_slice.m 7070 2024-12-09 17:21:10Z bgrychtol $</span>
0027 
0028 <span class="keyword">if</span> ischar(imdl) &amp;&amp; strcmp(imdl,<span class="string">'UNIT_TEST'</span>),<a href="#_sub5" class="code" title="subfunction do_unit_test">do_unit_test</a>;<span class="keyword">return</span>;<span class="keyword">end</span>;
0029 
0030 <span class="keyword">switch</span>(imdl.type)
0031     <span class="keyword">case</span> <span class="string">'inv_model'</span>
0032         fmdl = imdl.fwd_model;
0033     <span class="keyword">case</span> <span class="string">'fwd_model'</span>
0034         fmdl = imdl;
0035     <span class="keyword">otherwise</span>
0036         error(<span class="string">'An EIDORS inverse or forward model struct required'</span>);
0037 <span class="keyword">end</span>
0038 
0039 <span class="keyword">if</span> nargin &lt; 2
0040    opt = struct; 
0041 <span class="keyword">else</span>
0042    opt.level = level;   
0043 <span class="keyword">end</span>
0044 
0045 opt = <a href="#_sub3" class="code" title="subfunction opt = parse_opts(fmdl, opt)">parse_opts</a>(fmdl,opt);
0046 
0047 [rmdl fmdl] = <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction [rmdl fmdl] = do_pixel_slice(fmdl, opt);">do_pixel_slice</a>,{fmdl, opt},<span class="string">'mk_pixel_slice'</span>);
0048 
0049 <span class="keyword">switch</span> imdl.type
0050    <span class="keyword">case</span> <span class="string">'inv_model'</span>
0051       imdl.rec_model = rmdl;
0052       imdl.fwd_model = fmdl;
0053    <span class="keyword">case</span> <span class="string">'fwd_model'</span>
0054       imdl = rmdl;
0055 <span class="keyword">end</span>
0056 
0057 <a name="_sub1" href="#_subfunctions" class="code">function [rmdl fmdl] = do_pixel_slice(fmdl, opt);</a>
0058 [tmp, ~, ~, ifun] =<a href="../../eidors/graphics/matlab/level_model_slice.html" class="code" title="function [out, out2, out3, out4] = level_model_slice(varargin)">level_model_slice</a>(fmdl,opt.level);
0059 slc = <a href="../../eidors/graphics/matlab/mdl_slice_mesher.html" class="code" title="function [nimg out] = mdl_slice_mesher(fmdl,level,varargin)">mdl_slice_mesher</a>(tmp,[inf inf 0]);
0060 slc = slc.fwd_model;
0061 mingrid = min(slc.nodes);
0062 maxgrid = max(slc.nodes);
0063 bnd = <a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(slc);
0064 <span class="comment">% contour_boundary = order_loop(slc.nodes(unique(bnd),:));</span>
0065 
0066 <span class="keyword">if</span> opt.square_pixels ==1
0067     mdl_sz = maxgrid - mingrid;
0068     mdl_AR = mdl_sz(1)/mdl_sz(2);
0069     img_AR = opt.imgsz(1)/opt.imgsz(2);
0070     <span class="keyword">if</span> mdl_AR &lt; img_AR
0071         delta = (mdl_sz(2) * img_AR - mdl_sz(1)) /2;
0072         mingrid(1) = mingrid(1) - delta;
0073         maxgrid(1) = maxgrid(1) + delta;
0074     <span class="keyword">elseif</span> mdl_AR &gt; img_AR
0075         delta = (mdl_sz(1)/img_AR - mdl_sz(2)) / 2;
0076         mingrid(2) = mingrid(2) - delta;
0077         maxgrid(2) = maxgrid(2) + delta;
0078     <span class="keyword">end</span>
0079 <span class="keyword">end</span>
0080 
0081 xgrid = linspace(mingrid(1),maxgrid(1),opt.imgsz(1)+1);
0082 ygrid = linspace(mingrid(2),maxgrid(2),opt.imgsz(2)+1);
0083 rmdl = <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>([],xgrid,ygrid);
0084 x_pts = xgrid(1:end-1) + 0.5*diff(xgrid);
0085 y_pts = ygrid(1:end-1) + 0.5*diff(ygrid);
0086 <span class="comment">% y_pts = fliplr(y_pts); %medical</span>
0087 
0088 <span class="comment">% NOTE: This controls the image resolution. If you want higher res, you</span>
0089 <span class="comment">% need to either specify it in opt.imgsz or manually overwrite (or remove)</span>
0090 <span class="comment">% the imdl.rec_model.mdl_slice_mapper.</span>
0091 rmdl.mdl_slice_mapper.x_pts = x_pts;
0092 rmdl.mdl_slice_mapper.y_pts = y_pts;
0093 rmdl.mdl_slice_mapper.level = opt.level;
0094 rmdl.mdl_slice_mapper.model_2d = 1;
0095 x_avg = conv2(xgrid, [1,1]/2,<span class="string">'valid'</span>);
0096 y_avg = conv2(ygrid, [1,1]/2,<span class="string">'valid'</span>);
0097 [x,y] = ndgrid( x_avg, y_avg);
0098 
0099 <span class="comment">% 20141119: The inpolygon approach fails on non-simply-connected domains</span>
0100 <span class="comment">% inside = inpolygon(x(:),y(:),contour_boundary(:,1),contour_boundary(:,2) );</span>
0101 P = [x(:) y(:)]; <span class="comment">% P(end,3) = 0;</span>
0102 inside = any(<a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>(P, slc.elems, slc.nodes(:,1:2)),2);
0103 <span class="comment">% inside = full(inside);</span>
0104 
0105 ff = find(~inside);
0106 
0107 <span class="keyword">if</span> opt.do_coarse2fine
0108 <span class="comment">%     rmdl.mk_coarse_fine_mapping.z_depth = opt.z_depth;</span>
0109 <span class="comment">%     fmdl.coarse2fine = mk_coarse_fine_mapping(tmp,rmdl);</span>
0110 <span class="comment">%     fmdl.coarse2fine(:,ff) = [];</span>
0111     <span class="keyword">if</span> isinf(opt.z_depth)
0112        zgrid = [min(tmp.nodes(:,3))-1 max(tmp.nodes(:,3))+1];
0113     <span class="keyword">else</span>
0114        zgrid = [-opt.z_depth opt.z_depth];
0115     <span class="keyword">end</span>
0116     [~, c2f] = <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>(tmp,xgrid,ygrid,zgrid);
0117     c2f(:,ff) = [];
0118     fmdl = <a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'set'</span>,fmdl,<span class="string">'coarse2fine'</span>, c2f);
0119 <span class="keyword">end</span>
0120 
0121 rmdl.elems([2*ff, 2*ff-1],:)= [];
0122 rmdl.coarse2fine([2*ff, 2*ff-1],:)= [];
0123 rmdl.coarse2fine(:,ff)= [];
0124 <span class="comment">% rmdl.boundary = find_boundary(rmdl);</span>
0125 <span class="comment">% show individual elements (more like how the 2d grid models display)</span>
0126 rmdl.boundary = rmdl.elems;
0127 rmdl.inside   = inside; <span class="comment">% the inside array is useful in other functions</span>
0128 
0129 
0130 <span class="keyword">if</span> isfield(fmdl,<span class="string">'mat_idx'</span>)
0131    rmdl.mat_idx = <a href="#_sub2" class="code" title="subfunction mat_idx = calc_mat_idx(rmdl,fmdl,ff,opt)">calc_mat_idx</a>(rmdl,fmdl,ff,opt);
0132 <span class="keyword">end</span>
0133 
0134 <span class="comment">% map electrodes</span>
0135 rmdl.nodes(:,3) = 0;
0136 rmdl.nodes =  ifun(rmdl.nodes);
0137 slc.nodes =  ifun(slc.nodes);
0138 
0139 <span class="comment">% no longer needed, level_model_slice does this</span>
0140 <span class="comment">% if ~isstruct(opt.level)</span>
0141 <span class="comment">%    isf = ~isinf(opt.level);</span>
0142 <span class="comment">%    if nnz(isf) == 1</span>
0143 <span class="comment">%       rmdl.nodes(:,isf) = opt.level(:,isf);</span>
0144 <span class="comment">%    end</span>
0145 <span class="comment">% end</span>
0146 
0147 <span class="keyword">if</span> isfield(slc, <span class="string">'electrode'</span>)
0148    <span class="keyword">for</span> i = flipud(1:numel(slc.electrode))
0149         tmp = rmfield(slc.electrode(i), <span class="string">'nodes'</span>);
0150         x_elec = slc.nodes( [slc.electrode(i).nodes], 1);
0151         y_elec = slc.nodes( [slc.electrode(i).nodes], 2);
0152         z_elec = slc.nodes( [slc.electrode(i).nodes], 3);
0153         tmp.pos       = [x_elec, y_elec, z_elec];
0154         elec(i) = tmp;
0155     <span class="keyword">end</span>
0156     rmdl.electrode = elec;
0157 <span class="keyword">end</span>
0158    
0159 <span class="comment">% Not needed any more (uses fwd_model.mdl_slice_mapper)</span>
0160 <span class="comment">% rmdl.show_slices.levels = opt.level;</span>
0161 
0162 <span class="comment">% not quite correct, but 'rec_model' has many side effects</span>
0163 rmdl = <a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'fwd_model'</span>, rmdl); 
0164       
0165 
0166 <a name="_sub2" href="#_subfunctions" class="code">function mat_idx = calc_mat_idx(rmdl,fmdl,ff,opt)</a>
0167    <span class="comment">% calculate mat_idx for the rec_model</span>
0168    fmdl.mdl_slice_mapper = rmfield(rmdl.mdl_slice_mapper,<span class="string">'model_2d'</span>);
0169    fmdl.mdl_slice_mapper.level = opt.level;
0170    img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(fmdl,0);
0171    <span class="keyword">for</span> i = 1:length(fmdl.mat_idx);
0172       img.elem_data(fmdl.mat_idx{i}) = i;
0173    <span class="keyword">end</span>
0174    slice = <a href="../../eidors/graphics/matlab/calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(img); <span class="comment">% level specified in fmdl.mdl_slice_mapper</span>
0175    slice = slice';
0176    mat = reshape([slice(:)'; slice(:)'],1,[]);
0177    mat([2*ff, 2*ff-1])= [];
0178    mat_idx = cell(max(mat),1);
0179    <span class="keyword">for</span> i = 1:max(mat)
0180       mat_idx(i) = {find(mat==i)'};
0181    <span class="keyword">end</span>
0182 
0183 
0184  <a name="_sub3" href="#_subfunctions" class="code">function opt = parse_opts(fmdl, opt)</a>
0185     <span class="keyword">if</span> ~isfield(opt, <span class="string">'imgsz'</span>)     
0186         opt.imgsz = [32 32]; 
0187     <span class="keyword">end</span>
0188     <span class="keyword">if</span> ~isfield(opt, <span class="string">'square_pixels'</span>)
0189         opt.square_pixels = 0;
0190     <span class="keyword">end</span>
0191     <span class="keyword">if</span> ~isfield(opt, <span class="string">'level'</span>) || isempty(opt.level)
0192         opt.level = <a href="#_sub4" class="code" title="subfunction elec_lev = get_elec_level(fmdl)">get_elec_level</a>(fmdl);
0193     <span class="keyword">else</span>
0194         <span class="keyword">if</span> ~isstruct(opt.level) &amp;&amp; numel(opt.level) ==1
0195             opt.level = [inf inf opt.level];
0196         <span class="keyword">end</span>
0197     <span class="keyword">end</span>
0198     <span class="keyword">if</span> ~isfield(opt, <span class="string">'do_coarse2fine'</span>)
0199         opt.do_coarse2fine = 1;
0200     <span class="keyword">end</span>
0201     <span class="keyword">if</span> ~isfield(opt, <span class="string">'z_depth'</span>)
0202         opt.z_depth = inf;
0203     <span class="keyword">end</span>
0204     
0205 <a name="_sub4" href="#_subfunctions" class="code">function elec_lev = get_elec_level(fmdl)</a>
0206     z_elec= fmdl.nodes( [fmdl.electrode(:).nodes], 3);
0207     min_e = min(z_elec); max_e = max(z_elec);
0208     elec_lev = [inf,inf,mean([min_e,max_e])];
0209 
0210     
0211 <a name="_sub5" href="#_subfunctions" class="code">function do_unit_test</a>
0212     imdl = <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,[16,2]);
0213     opt.square_pixels = 1;
0214     opt.imgsz = [16 16];
0215     mdl = <a href="mk_pixel_slice.html" class="code" title="function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)">mk_pixel_slice</a>(imdl.fwd_model,[inf 2 2.5], opt);
0216     img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl,1);
0217     
0218     subplot(231)
0219     <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imdl.fwd_model);
0220     view([-50 10])
0221 
0222     subplot(232)
0223     <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img);
0224     zlim([0 3]);
0225     ylim([-1 1])
0226     xlim([-1 1]);
0227     view([-50 10])
0228     
0229     subplot(233)
0230     <a href="../../eidors/graphics/matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>(img);
0231     
0232     subplot(234)
0233     imdl = <a href="mk_pixel_slice.html" class="code" title="function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)">mk_pixel_slice</a>(imdl);
0234     img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl.rec_model,1);
0235     <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img);
0236     zlim([0 3]);
0237     ylim([-1 1])
0238     xlim([-1 1]);
0239     view([-50 10])
0240     
0241     subplot(235)
0242     mdl = <a href="mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft,scale)">mk_library_model</a>(<span class="string">'pig_23kg_16el_lungs'</span>);
0243     img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl,1);
0244     <span class="keyword">for</span> i = 1:length(mdl.mat_idx)
0245        img.elem_data(mdl.mat_idx{i}) = i;
0246     <span class="keyword">end</span>
0247     <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img)
0248     view(2)
0249     
0250     subplot(236)
0251     clear opt
0252     opt.imgsz = [64 64];
0253     opt.square_pixels = 1;
0254     opt.do_coarse2fine = 0;
0255     mdl = <a href="mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft,scale)">mk_library_model</a>(<span class="string">'pig_23kg_16el_lungs'</span>);
0256 <span class="comment">%     rmdl = mk_pixel_slice(mdl,opt); % deprecated</span>
0257     rmdl = <a href="mk_pixel_slice.html" class="code" title="function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)">mk_pixel_slice</a>(mdl,[],opt);
0258     img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(rmdl,1);
0259     <span class="keyword">for</span> i = 1:length(rmdl.mat_idx)
0260        img.elem_data(rmdl.mat_idx{i}) = i;
0261     <span class="keyword">end</span>
0262     <a href="../../eidors/graphics/matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels, vh )">show_slices</a>(img);</pre></div>
<hr><address>Generated on Sun 29-Dec-2024 19:54:43 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>