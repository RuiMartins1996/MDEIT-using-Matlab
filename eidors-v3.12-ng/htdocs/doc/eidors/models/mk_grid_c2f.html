<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mk_grid_c2f</title>
  <meta name="keywords" content="mk_grid_c2f">
  <meta name="description" content="MK_GRID_C2F - calculate a coarse2fine mapping for grid coarse models.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">models</a> &gt; mk_grid_c2f.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/models&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>mk_grid_c2f
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>MK_GRID_C2F - calculate a coarse2fine mapping for grid coarse models.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">MK_GRID_C2F - calculate a coarse2fine mapping for grid coarse models.
 C2F = MK_GRID_C2F(FMDL,RMDL) returns in C2F the fraction of volume of
 each element of the fine (tet-based) model contained in each element of
 the coarse (vox-based) model.
 Uses CONVHULLN to calculate the volume defined by a set of intersection
 points between individual tet and vox elements.

 C2F = MK_GRID_C2F(FMDL,RMDL,OPT) allows specifying options.
 
 Inputs:
   FMDL - an EIDORS (tet-based) forward model
   RMDL - a grid model, as returned by MK_GRID_MODEL
   OPT  - an option structure with the following fields and defaults:
      .do_not_scale  - set to true to prevent scaling the models to unit
                       cube before any calculations, including thresholds.
                       Default: false
      .tol_node2tet  - tolerance for determinant &lt;= 0 in testing for
                       points inside tets. Default: eps
      .tol_edge2edge - maximum distance between &quot;intersecting&quot; edges
                       Default: 6*sqrt(3)*eps(a), where a is
                       min(max(abs(fmdl.nodes(:))),max(abs(rmdl.nodes(:)))
      .tol_edge2tri  - minimum value of a barycentric coordinate to 
                       decide a point is lying inside a triangle.
                       Default: eps
      .save_memory   - modifies function behavior to decrease memory 
                       footprint by increasing the number of iterations;
                       useful for large problems. Must be an integer 
                       between 0 and 3
                          0  -  calculate all at once (default)
                          1  -  calculate one xy voxel plane at a time
                          2  -  calculate one y voxel row at a time
                          3  -  calculate each voxel separately
                       NOTE: read below about persistent usage

 MK_GRID_C2F('save_memory',N) sets the 'save memory' option for all future
 calls (persistent variable). N will be used when opt.save_memory is not
 specified.

 [C2F M] = MK_GRID_C2F(...) also returns a struct with useful fields
 characterising the vox model

 Set eidors_msg 'log level' &lt; 2 to supress output to command line.

 Examples:
     fmdl = ng_mk_cyl_models([2,2,.2],[],[]);
     rmdl = mk_grid_model([],-2:2,-2:2,0:2);
     c2f  = mk_grid_c2f(fmdl,rmdl);
     h = show_fem(fmdl); set(h,'LineWidth',0.1)
     hold on
     h = show_fem(rmdl); set(h,'EdgeColor','b','LineWidth',2);
     hold off

 See also <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">MK_GRID_MODEL</a>, <a href="find_edge2edge_intersections.html" class="code" title="function [pts,FE2CE,FE2pts,CE2pts] = find_edge2edge_intersections(FE,FN,CE,CN, epsilon)">FIND_EDGE2EDGE_INTERSECTIONS</a>, CONVHULLN
     <a href="mk_tet_c2f.html" class="code" title="function [c2f] = mk_tet_c2f(fmdl, rmdl, opt)">MK_TET_C2F</a>, <a href="mk_approx_c2f.html" class="code" title="function [mapping, outside] = mk_approx_c2f( f_mdl, c_mdl );">MK_APPROX_C2F</a>, <a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">POINT_IN_TRIANGLE</a>, EIDORS_MSG</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../eidors/meshing/netgen/ng_mk_cyl_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_cyl_models(cyl_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_cyl_models</a>	NG_MAKE_CYL_MODELS: create cylindrical models using netgen</li><li><a href="convhulln_clean.html" class="code" title="function [K,V] = convhulln_clean(pts,p);">convhulln_clean</a>	CONVHULLN_CLEAN: run convhulln and catch errors</li><li><a href="find_edge2edge_intersections.html" class="code" title="function [pts,FE2CE,FE2pts,CE2pts] = find_edge2edge_intersections(FE,FN,CE,CN, epsilon)">find_edge2edge_intersections</a>	FIND_EDGE2EDGE_INTERSECTIONS intersections between edges of two models</li><li><a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>	FIX_MODEL: Add useful fields to a model</li><li><a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>	GET_ELEM_VOLUME: VOL = get_elem_volume(fwd_model, map_node )</li><li><a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>	INTERP_MESH: calculate interpolation points onto mdl elements</li><li><a href="mk_approx_c2f.html" class="code" title="function [mapping, outside] = mk_approx_c2f( f_mdl, c_mdl );">mk_approx_c2f</a>	MK_APPROX_C2F: create a mapping matrix from coarse to fine FEM</li><li><a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>	MK_GRID_C2F - calculate a coarse2fine mapping for grid coarse models.</li><li><a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="num_elems.html" class="code" title="function num = num_elems( mdl );">num_elems</a>	NUM_ELEMS: number of elemnts in a (fwd or inv model or image)</li><li><a href="num_nodes.html" class="code" title="function num = num_nodes( mdl );">num_nodes</a>	NUM_NODES: number of elemnts in a (fwd or inv model or image)</li><li><a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>	POINT_IN_TRIANGLE tests points for membership in triangles</li><li><a href="tet_to_inequal.html" class="code" title="function [A,b]=tet_to_inequal(v,e)">tet_to_inequal</a>	[A,b]=tet_to_inequal(v)</li><li><a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload for Matlab < R2020a / 9.8).</li><li><a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>	EIDORS_DEBUG Global managment of debug flags</li><li><a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>	PROGRESS_MSG Progress messages and timing.</li><li><a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/graphics/matlab/calc_voxels.html" class="code" title="function [V, rimg] = calc_voxels(img, opt, level)">calc_voxels</a>	CALC_VOXELS Calculate volumetric data from an image</li><li><a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>	MK_GRID_C2F - calculate a coarse2fine mapping for grid coarse models.</li><li><a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="mk_tet_c2f.html" class="code" title="function [c2f] = mk_tet_c2f(fmdl, rmdl, opt)">mk_tet_c2f</a>	MK_TET_C2F - calculate a coarse2fine mapping for two tet-based models.</li><li><a href="mk_tri2tet_c2f.html" class="code" title="function c2f = mk_tri2tet_c2f(fmdl,rmdl, opt)">mk_tri2tet_c2f</a>	MK_TRI2TET_C2F - coarse2fine mapping between tri-based and tet-based models</li><li><a href="mk_voxel_volume.html" class="code" title="function [imdl, fmdl] = mk_voxel_volume(varargin)">mk_voxel_volume</a>	MK_VOXEL_VOLUME create a voxel model to reconstruct on</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [c2f, m]= do_mk_grid_c2f(fmdl0,rmdl0,opt0)</a></li><li><a href="#_sub2" class="code">function c2f = combine_c2f(c2f, tmp,felem_idx,relem_idx)</a></li><li><a href="#_sub3" class="code">function [c2f, m] = separable_calculations(fmdl,rmdl,opt)</a></li><li><a href="#_sub4" class="code">function [fmdl, rmdl, opt, felem_idx] = crop_models(fmdl0,rmdl0,opt, relem_idx)</a></li><li><a href="#_sub5" class="code">function fmdl = prepare_fmdl(fmdl)</a></li><li><a href="#_sub6" class="code">function m = prepare_vox_mdl(rmdl,opt)</a></li><li><a href="#_sub7" class="code">function rnode2tet = get_nodes_in_tets(fmdl,rmdl, opt)</a></li><li><a href="#_sub8" class="code">function [insnode] = get_nodes_in_voxels(fmdl,rmdl)</a></li><li><a href="#_sub9" class="code">function [intpts, face2edge, face2intpt, edge2intpt] = get_voxel_intersection_points(fmdl,faces,opt)</a></li><li><a href="#_sub10" class="code">function [intpts, tri2edge, tri2intpt, edge2intpt] = get_tet_intersection_points(fmdl,m,opt)</a></li><li><a href="#_sub11" class="code">function [voxels, node2vox] = mk_voxels(opt)</a></li><li><a href="#_sub12" class="code">function faces = mk_faces(voxels,opt)</a></li><li><a href="#_sub13" class="code">function edges = mk_edges(voxels, opt)</a></li><li><a href="#_sub14" class="code">function vox2face = mk_vox2face(opt)</a></li><li><a href="#_sub15" class="code">function [vox2edge, vol] = mk_vox2edge(m,opt)</a></li><li><a href="#_sub16" class="code">function show_voxels(rmdl,voxels)</a></li><li><a href="#_sub17" class="code">function test_faces(rmdl, faces, opt)</a></li><li><a href="#_sub18" class="code">function [fmdl,rmdl] = center_scale_models(fmdl,rmdl, opt)</a></li><li><a href="#_sub19" class="code">function rmdl = rmdl_3D(rmdl, fmdl)</a></li><li><a href="#_sub20" class="code">function opt = parse_opts(fmdl,rmdl, opt)</a></li><li><a href="#_sub21" class="code">function logmsg(varargin)</a></li><li><a href="#_sub22" class="code">function do_unit_test</a></li><li><a href="#_sub23" class="code">function do_case_tests</a></li><li><a href="#_sub24" class="code">function do_small_test</a></li><li><a href="#_sub25" class="code">function do_realistic_test</a></li><li><a href="#_sub26" class="code">function do_edge2edge_timing_test</a></li><li><a href="#_sub27" class="code">function rnode2tet = test_vnode_in_tet(rmdl,fmdl)</a></li><li><a href="#_sub28" class="code">function [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)</a></li><li><a href="#_sub29" class="code">function [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)</a></li><li><a href="#_sub30" class="code">function [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)</a></li><li><a href="#_sub31" class="code">function [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)</a></li><li><a href="#_sub32" class="code">function show_test(vox,tet)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)</a>
0002 <span class="comment">%MK_GRID_C2F - calculate a coarse2fine mapping for grid coarse models.</span>
0003 <span class="comment">% C2F = MK_GRID_C2F(FMDL,RMDL) returns in C2F the fraction of volume of</span>
0004 <span class="comment">% each element of the fine (tet-based) model contained in each element of</span>
0005 <span class="comment">% the coarse (vox-based) model.</span>
0006 <span class="comment">% Uses CONVHULLN to calculate the volume defined by a set of intersection</span>
0007 <span class="comment">% points between individual tet and vox elements.</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% C2F = MK_GRID_C2F(FMDL,RMDL,OPT) allows specifying options.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% Inputs:</span>
0012 <span class="comment">%   FMDL - an EIDORS (tet-based) forward model</span>
0013 <span class="comment">%   RMDL - a grid model, as returned by MK_GRID_MODEL</span>
0014 <span class="comment">%   OPT  - an option structure with the following fields and defaults:</span>
0015 <span class="comment">%      .do_not_scale  - set to true to prevent scaling the models to unit</span>
0016 <span class="comment">%                       cube before any calculations, including thresholds.</span>
0017 <span class="comment">%                       Default: false</span>
0018 <span class="comment">%      .tol_node2tet  - tolerance for determinant &lt;= 0 in testing for</span>
0019 <span class="comment">%                       points inside tets. Default: eps</span>
0020 <span class="comment">%      .tol_edge2edge - maximum distance between &quot;intersecting&quot; edges</span>
0021 <span class="comment">%                       Default: 6*sqrt(3)*eps(a), where a is</span>
0022 <span class="comment">%                       min(max(abs(fmdl.nodes(:))),max(abs(rmdl.nodes(:)))</span>
0023 <span class="comment">%      .tol_edge2tri  - minimum value of a barycentric coordinate to</span>
0024 <span class="comment">%                       decide a point is lying inside a triangle.</span>
0025 <span class="comment">%                       Default: eps</span>
0026 <span class="comment">%      .save_memory   - modifies function behavior to decrease memory</span>
0027 <span class="comment">%                       footprint by increasing the number of iterations;</span>
0028 <span class="comment">%                       useful for large problems. Must be an integer</span>
0029 <span class="comment">%                       between 0 and 3</span>
0030 <span class="comment">%                          0  -  calculate all at once (default)</span>
0031 <span class="comment">%                          1  -  calculate one xy voxel plane at a time</span>
0032 <span class="comment">%                          2  -  calculate one y voxel row at a time</span>
0033 <span class="comment">%                          3  -  calculate each voxel separately</span>
0034 <span class="comment">%                       NOTE: read below about persistent usage</span>
0035 <span class="comment">%</span>
0036 <span class="comment">% MK_GRID_C2F('save_memory',N) sets the 'save memory' option for all future</span>
0037 <span class="comment">% calls (persistent variable). N will be used when opt.save_memory is not</span>
0038 <span class="comment">% specified.</span>
0039 <span class="comment">%</span>
0040 <span class="comment">% [C2F M] = MK_GRID_C2F(...) also returns a struct with useful fields</span>
0041 <span class="comment">% characterising the vox model</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% Set eidors_msg 'log level' &lt; 2 to supress output to command line.</span>
0044 <span class="comment">%</span>
0045 <span class="comment">% Examples:</span>
0046 <span class="comment">%     fmdl = ng_mk_cyl_models([2,2,.2],[],[]);</span>
0047 <span class="comment">%     rmdl = mk_grid_model([],-2:2,-2:2,0:2);</span>
0048 <span class="comment">%     c2f  = mk_grid_c2f(fmdl,rmdl);</span>
0049 <span class="comment">%     h = show_fem(fmdl); set(h,'LineWidth',0.1)</span>
0050 <span class="comment">%     hold on</span>
0051 <span class="comment">%     h = show_fem(rmdl); set(h,'EdgeColor','b','LineWidth',2);</span>
0052 <span class="comment">%     hold off</span>
0053 <span class="comment">%</span>
0054 <span class="comment">% See also MK_GRID_MODEL, FIND_EDGE2EDGE_INTERSECTIONS, CONVHULLN</span>
0055 <span class="comment">%     MK_TET_C2F, MK_APPROX_C2F, POINT_IN_TRIANGLE, EIDORS_MSG</span>
0056 
0057 <span class="comment">% (C) 2015 Bartlomiej Grychtol - all rights reserved by Swisstom AG</span>
0058 <span class="comment">% License: GPL version 2 or 3</span>
0059 <span class="comment">% $Id: mk_grid_c2f.m 7040 2024-11-30 00:02:08Z bgrychtol $</span>
0060 
0061 <span class="keyword">persistent</span> save_memory;
0062 
0063 <span class="keyword">if</span> ischar(fmdl) &amp;&amp; strcmp(fmdl,<span class="string">'UNIT_TEST'</span>), <a href="#_sub22" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0064 <span class="keyword">if</span> ischar(fmdl) &amp;&amp; strcmp(fmdl,<span class="string">'PROFILE'</span>), <a href="#_sub24" class="code" title="subfunction do_small_test">do_small_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0065 <span class="keyword">if</span> ischar(fmdl) &amp;&amp; strcmp(fmdl,<span class="string">'save_memory'</span>)
0066    <span class="keyword">if</span> nargin ~= 2, error(<span class="string">'Expected a value for save_memory option'</span>); <span class="keyword">end</span>
0067    <span class="keyword">if</span> ischar(rmdl), rmdl = str2double(rmdl); <span class="keyword">end</span>
0068    save_memory = rmdl;
0069    <span class="keyword">return</span>
0070 <span class="keyword">end</span>
0071 <span class="keyword">if</span> nargin &lt; 3
0072    opt = struct;
0073 <span class="keyword">end</span>
0074 <span class="keyword">if</span> ~isempty(save_memory)
0075    <span class="keyword">try</span> 
0076       opt.save_memory; <span class="comment">% command line options have precedence</span>
0077    <span class="keyword">catch</span>
0078       opt.save_memory = save_memory;
0079    <span class="keyword">end</span>
0080 <span class="keyword">end</span>
0081 
0082 [fmdl,rmdl] = <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub18" class="code" title="subfunction [fmdl,rmdl] = center_scale_models(fmdl,rmdl, opt)">center_scale_models</a>,{fmdl,rmdl, opt});
0083 
0084 opt = <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub20" class="code" title="subfunction opt = parse_opts(fmdl,rmdl, opt)">parse_opts</a>,{fmdl,rmdl, opt});
0085 
0086 copt.cache_obj = {fmdl.nodes,
0087                   fmdl.elems,
0088                   rmdl.nodes,
0089                   rmdl.elems,
0090                   rmfield(opt,<span class="string">'save_memory'</span>)};
0091                
0092 copt.fstr = <span class="string">'mk_grid_c2f'</span>;
0093 
0094 [c2f, m] = <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction [c2f, m]= do_mk_grid_c2f(fmdl0,rmdl0,opt0)">do_mk_grid_c2f</a>,{fmdl,rmdl,opt},copt);
0095 
0096 
0097 
0098 <span class="comment">%-------------------------------------------------------------------------%</span>
0099 <span class="comment">% Wrapper providing the save_memory functionality</span>
0100 <a name="_sub1" href="#_subfunctions" class="code">function [c2f, m]= do_mk_grid_c2f(fmdl0,rmdl0,opt0)</a>
0101     <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@'</span>,2);
0102     
0103     m = [];
0104     c2f = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(opt0.nTet,opt0.nVox);
0105    
0106     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Prepare tet model...'</span>);
0107     fmdl0 = <a href="#_sub5" class="code" title="subfunction fmdl = prepare_fmdl(fmdl)">prepare_fmdl</a>(fmdl0);
0108     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(Inf);
0109     
0110     <span class="keyword">if</span> opt0.save_memory == 0
0111        relem_idx = ones(opt0.nVox,1);
0112        [fmdl, rmdl, opt, felem_idx] = <a href="#_sub4" class="code" title="subfunction [fmdl, rmdl, opt, felem_idx] = crop_models(fmdl0,rmdl0,opt, relem_idx)">crop_models</a>(fmdl0,rmdl0,opt0,relem_idx);
0113        <span class="keyword">if</span> any(felem_idx)
0114           [tmp, m] = <a href="#_sub3" class="code" title="subfunction [c2f, m] = separable_calculations(fmdl,rmdl,opt)">separable_calculations</a>(fmdl,rmdl0,opt);
0115           c2f = <a href="#_sub2" class="code" title="subfunction c2f = combine_c2f(c2f, tmp,felem_idx,relem_idx)">combine_c2f</a>(c2f, tmp,felem_idx,relem_idx);
0116        <span class="keyword">end</span>
0117     <span class="keyword">elseif</span> opt0.save_memory == 10
0118 <span class="comment">% The idea here is to calculate separately on each fraction</span>
0119 <span class="comment">% of the model. It should then be possible to run in a parfor</span>
0120 <span class="comment">% loop, ... but matlab has subtle bugs</span>
0121        <a href="#_sub21" class="code" title="subfunction logmsg(varargin)">logmsg</a>(<span class="string">' Saving memory mode level %d\n'</span>,opt0.save_memory);
0122        n_elems = <a href="num_elems.html" class="code" title="function num = num_elems( mdl );">num_elems</a>(fmdl0); step = 5e4;
0123        max_iter = floor(n_elems/step);
0124        pmopt.final_msg = <span class="string">''</span>;
0125        ctr = <a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(fmdl0);
0126        [~,xidx] = sort(ctr(:,1)); <span class="comment">% sort by x - real solution is travelling salesman</span>
0127        [xl] = ndgrid(opt0.xvec(1:end-1),opt0.yvec(1:end-1),opt0.zvec(1:end-1)); xl=xl(:);
0128        [xu] = ndgrid(opt0.xvec(2:end-0),opt0.yvec(2:end-0),opt0.zvec(2:end-0)); xu=xu(:);
0129        <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Progress:'</span>,0,max_iter+1,pmopt);
0130        progress = 0;
0131        <span class="keyword">for</span> k = 0:max_iter;
0132           eidx = true(n_elems,1);
0133           eidx( xidx((k*step+1):min((k+1)*step,n_elems)) ) = false;
0134           fmdl = fmdl0; fmdl.elems(eidx,:) = [];
0135                         fmdl.edge2elem(:,eidx)= [];
0136                         fmdl.node2elem(:,eidx)= [];
0137                         fmdl.elem2face(eidx,:)= [];
0138           opt = opt0;   opt.nTet = sum(eidx==0);
0139 <span class="keyword">if</span> 1
0140           xvals = fmdl.nodes(fmdl.elems(:),1);
0141           ridx = true(size(xu));
0142           ridx(xl&gt;max(xvals)) = false;
0143           ridx(xu&lt;min(xvals)) = false;
0144           rmdl = rmdl0; 
0145              idx = rmdl0.coarse2fine * ridx &gt; 0;
0146              rmdl.elems = rmdl0.elems(idx,:);
0147              [node_idx, ~,Nn] = unique(rmdl.elems(:));
0148              rmdl.elems = reshape(Nn,size(rmdl.elems));
0149              rmdl.nodes = rmdl0.nodes(node_idx,:);
0150           opt.xvec = unique(rmdl.nodes( rmdl.elems(:), 1));
0151           opt.Xsz = length(opt.xvec)-1;
0152           opt.ystep = opt.xstep*opt.Xsz+1;
0153           opt.zstep = opt.ystep*(opt.Ysz+1);
0154           opt.nVox = opt.Xsz*opt.Ysz*opt.Zsz;
0155 
0156    <span class="keyword">if</span> 0 <span class="comment">% Display the cut model for debugging</span>
0157           fmdl.boundary = <a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(fmdl);
0158           rmdl.boundary = <a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(rmdl);
0159           hh=<a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(rmdl); set(hh,<span class="string">'EdgeColor'</span>,[0,0,1]);
0160               hold on; <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(fmdl); hold off; keyboard
0161    <span class="keyword">end</span>
0162 <span class="keyword">else</span>    <span class="comment">% Test code: don't cut the rmdl - slower but correct</span>
0163           rmdl = rmdl0; ridx= true(opt.nVox,1);
0164 <span class="keyword">end</span>
0165           <span class="keyword">if</span> isempty(rmdl.elems); <span class="keyword">continue</span>; <span class="keyword">end</span> <span class="comment">% don't bother if rmdl outside</span>
0166 
0167           <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,<a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>)-2);
0168           c2f(~eidx,ridx) = <a href="#_sub3" class="code" title="subfunction [c2f, m] = separable_calculations(fmdl,rmdl,opt)">separable_calculations</a>(fmdl,rmdl,opt);
0169           <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,<a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>)+2);
0170           <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(k+1, max_iter+1);
0171        <span class="keyword">end</span>
0172        <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(Inf);
0173     <span class="keyword">else</span> <span class="comment">% save_memory &gt; 0</span>
0174        <a href="#_sub21" class="code" title="subfunction logmsg(varargin)">logmsg</a>(<span class="string">' Saving memory mode level %d\n'</span>,opt0.save_memory);
0175        max_iter = opt0.Zsz;
0176        <span class="keyword">if</span> opt0.save_memory &gt;= 2, max_iter = max_iter * opt0.Ysz; <span class="keyword">end</span>
0177        <span class="keyword">if</span> opt0.save_memory == 3, max_iter = max_iter * opt0.Xsz; <span class="keyword">end</span>
0178        pmopt.final_msg = <span class="string">''</span>;
0179        <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Progress:'</span>,0,max_iter,pmopt);
0180        progress = 0;
0181        opt = opt0;
0182        m = <a href="#_sub6" class="code" title="subfunction m = prepare_vox_mdl(rmdl,opt)">prepare_vox_mdl</a>(rmdl0,opt0);
0183        <span class="keyword">for</span> z = 1:opt0.Zsz
0184           opt.Zsz = 1;
0185           opt.zvec = opt0.zvec(z:z+1);
0186           opt.xplane = opt0.xplane(z,:);
0187           opt.yplane = opt0.yplane(z,:);
0188           relem_idx = false(opt0.Xsz*opt0.Ysz*opt0.Zsz,1);
0189           relem_idx((z-1)*opt0.Xsz*opt0.Ysz + (1:opt0.Xsz*opt0.Ysz)) = true;
0190           <span class="keyword">if</span> opt0.save_memory &gt; 1
0191              <span class="keyword">for</span> y = 1:opt0.Ysz
0192                 opt.Ysz = 1;
0193                 opt.yvec = opt0.yvec(y:y+1);
0194                 opt.zplane = opt0.zplane(y,:);
0195                 opt.xplane = opt0.xplane(z,y);
0196                 opt.zstep = opt.ystep*(opt.Ysz+1);
0197                 relem_idx_y = false(opt0.Xsz*opt0.Ysz,1);
0198                 relem_idx_y((y-1)*opt0.Xsz + (1:opt0.Xsz)) = true;
0199                 relem_idx_y = relem_idx &amp; repmat(relem_idx_y,opt0.Zsz,1);
0200                 <span class="keyword">if</span> opt0.save_memory &gt; 2
0201                    <span class="keyword">for</span> x = 1:opt0.Xsz
0202                       opt.Xsz = 1;
0203                       opt.xvec = opt0.xvec(x:x+1);
0204                       opt.yplane = opt0.yplane(z,x);
0205                       opt.zplane = opt0.zplane(y,x);
0206                       opt.ystep = opt.xstep*opt.Xsz+1;
0207                       opt.zstep = opt.ystep*(opt.Ysz+1);
0208                       relem_idx_x = false(opt0.Xsz,1);
0209                       relem_idx_x(x) = true;
0210                       relem_idx_x = relem_idx_y &amp; repmat(relem_idx_x,opt0.Ysz*opt0.Zsz,1);
0211                       [fmdl, rmdl, opt, felem_idx] = <a href="#_sub4" class="code" title="subfunction [fmdl, rmdl, opt, felem_idx] = crop_models(fmdl0,rmdl0,opt, relem_idx)">crop_models</a>(fmdl0,rmdl0,opt,relem_idx_x);
0212                       <span class="keyword">if</span> any(felem_idx)
0213                          <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,<a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>)-2);
0214                          tmp = <a href="#_sub3" class="code" title="subfunction [c2f, m] = separable_calculations(fmdl,rmdl,opt)">separable_calculations</a>(fmdl,rmdl,opt);
0215                          <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,<a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>)+2);
0216                          c2f = <a href="#_sub2" class="code" title="subfunction c2f = combine_c2f(c2f, tmp,felem_idx,relem_idx)">combine_c2f</a>(c2f, tmp,felem_idx,relem_idx_x);
0217                       <span class="keyword">end</span>
0218                       progress = progress + 1;
0219                       <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(progress,max_iter);
0220                    <span class="keyword">end</span>
0221                 <span class="keyword">else</span>
0222                    [fmdl, rmdl, opt, felem_idx] = <a href="#_sub4" class="code" title="subfunction [fmdl, rmdl, opt, felem_idx] = crop_models(fmdl0,rmdl0,opt, relem_idx)">crop_models</a>(fmdl0,rmdl0,opt,relem_idx_y);
0223                    <span class="keyword">if</span> any(felem_idx)
0224                       <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,<a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>)-2);
0225                       tmp = <a href="#_sub3" class="code" title="subfunction [c2f, m] = separable_calculations(fmdl,rmdl,opt)">separable_calculations</a>(fmdl,rmdl,opt);
0226                       <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,<a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>)+2);
0227                       c2f = <a href="#_sub2" class="code" title="subfunction c2f = combine_c2f(c2f, tmp,felem_idx,relem_idx)">combine_c2f</a>(c2f, tmp,felem_idx,relem_idx_y);
0228                    <span class="keyword">end</span>
0229                    progress = progress + 1;
0230                    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(progress, max_iter);
0231                 <span class="keyword">end</span>
0232              <span class="keyword">end</span>
0233 
0234           <span class="keyword">else</span>
0235              [fmdl, rmdl, opt, felem_idx] = <a href="#_sub4" class="code" title="subfunction [fmdl, rmdl, opt, felem_idx] = crop_models(fmdl0,rmdl0,opt, relem_idx)">crop_models</a>(fmdl0,rmdl0,opt,relem_idx);
0236              <span class="keyword">if</span> any(felem_idx)
0237                 <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,<a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>)-2);
0238                 tmp = <a href="#_sub3" class="code" title="subfunction [c2f, m] = separable_calculations(fmdl,rmdl,opt)">separable_calculations</a>(fmdl,rmdl,opt);
0239                 <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,<a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>)+2);
0240                 c2f = <a href="#_sub2" class="code" title="subfunction c2f = combine_c2f(c2f, tmp,felem_idx,relem_idx)">combine_c2f</a>(c2f, tmp,felem_idx,relem_idx);
0241              <span class="keyword">end</span>
0242              progress = progress + 1;
0243              <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(progress, max_iter);
0244           <span class="keyword">end</span>
0245           
0246           
0247        <span class="keyword">end</span>
0248        <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(Inf);
0249     <span class="keyword">end</span>
0250 
0251 <span class="comment">%-------------------------------------------------------------------------%</span>
0252 <span class="comment">% Wrapper helper, combines partial c2f matrices</span>
0253 <a name="_sub2" href="#_subfunctions" class="code">function c2f = combine_c2f(c2f, tmp,felem_idx,relem_idx)</a>
0254     fidx = find(felem_idx); 
0255     ridx = find(relem_idx);
0256     c2f(fidx,ridx) = c2f(fidx,ridx) + tmp;
0257     
0258 <span class="comment">%-------------------------------------------------------------------------%</span>
0259 <span class="comment">% The main function</span>
0260 <a name="_sub3" href="#_subfunctions" class="code">function [c2f, m] = separable_calculations(fmdl,rmdl,opt)</a>
0261     DEBUG = <a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>(<span class="string">'query'</span>,<span class="string">'mk_grid_c2f'</span>);
0262    
0263     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Prepare vox model...'</span>);
0264     m = <a href="#_sub6" class="code" title="subfunction m = prepare_vox_mdl(rmdl,opt)">prepare_vox_mdl</a>(rmdl,opt);
0265     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(Inf);
0266     
0267     <span class="keyword">try</span>
0268     
0269     <span class="comment">% tet edge v. vox face</span>
0270     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find tet_edge2vox_face intersections...'</span>)
0271     [intpts1, rec2tedge, rec2intpt1, tedge2intpt1] = <a href="#_sub9" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = get_voxel_intersection_points(fmdl,faces,opt)">get_voxel_intersection_points</a>(fmdl,m.faces,opt);
0272     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>, size(intpts1,1)), Inf);
0273     
0274     <span class="comment">% vox edge v. tet face</span>
0275     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find vox_edge2tet_face intersections...'</span>,0,3)
0276     [intpts2, tri2vedge, tri2intpt2, vedge2intpt2] = <a href="#_sub10" class="code" title="subfunction [intpts, tri2edge, tri2intpt, edge2intpt] = get_tet_intersection_points(fmdl,m,opt)">get_tet_intersection_points</a>(fmdl,m,opt);
0277     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>, size(intpts2,1)), Inf);
0278     
0279     <span class="comment">% Note: Rather than calculating edge2edge intersections, one could</span>
0280     <span class="comment">% include them in one or both of the previous tests. However, it is</span>
0281     <span class="comment">% then difficult to guarantee that the numerically border-line cases</span>
0282     <span class="comment">% get assigned to all the vox and tets concerned</span>
0283     
0284     <span class="comment">% vox edge v. tet edge</span>
0285     pmopt.final_msg = <span class="string">'none'</span>;   
0286     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find tet_edge2vox_edge intersections...'</span>,-1,pmopt)
0287     [intpts3, tedge2vedge, tedge2intpt3, vedge2intpt3] =<a href="find_edge2edge_intersections.html" class="code" title="function [pts,FE2CE,FE2pts,CE2pts] = find_edge2edge_intersections(FE,FN,CE,CN, epsilon)">find_edge2edge_intersections</a>(fmdl.edges,fmdl.nodes,m.edges,rmdl.nodes, opt.tol_edge2edge); 
0288     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>,size(intpts3,1)),Inf);
0289     
0290     <span class="comment">% tet node in vox</span>
0291     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find tet_nodes in voxels...'</span>)
0292     [fnode2vox] = <a href="#_sub8" class="code" title="subfunction [insnode] = get_nodes_in_voxels(fmdl,rmdl)">get_nodes_in_voxels</a>(fmdl,rmdl);
0293     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>, nnz(fnode2vox)), Inf);
0294     
0295     <span class="comment">% vox node in tet</span>
0296     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find vox_nodes in tets...'</span>);
0297     vnode2tet = <a href="#_sub7" class="code" title="subfunction rnode2tet = get_nodes_in_tets(fmdl,rmdl, opt)">get_nodes_in_tets</a>(fmdl,rmdl, opt);
0298     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>, nnz(vnode2tet)), Inf);
0299     
0300     <span class="comment">% vox contained in tet</span>
0301     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find vox contained in tet...'</span>)
0302     vox_in_tet = (m.node2vox' * vnode2tet) == 8;
0303     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>,nnz(vox_in_tet)), Inf);
0304     
0305     <span class="comment">% tet contained in vox</span>
0306     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find tets contained in vox...'</span>);
0307     tet_in_vox = (double(fmdl.node2elem') * fnode2vox) == 4;
0308     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>,nnz(tet_in_vox)), Inf);
0309     
0310     
0311     <span class="comment">% tets and vox that intersect</span>
0312     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find total vox v. tet intersections...'</span>);
0313     vox2intTet =   m.vox2face * (rec2tedge&gt;0) * fmdl.edge2elem <span class="keyword">...</span>
0314                  | m.vox2edge * (tri2vedge&gt;0)' * fmdl.elem2face' <span class="keyword">...</span>
0315                  | m.vox2edge * tedge2vedge' * fmdl.edge2elem;
0316     <span class="comment">% exclude complete inclusion</span>
0317     vox2intTet = vox2intTet &amp; ~vox_in_tet &amp; ~tet_in_vox';
0318     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>,nnz(vox2intTet)), Inf);
0319     
0320     <span class="keyword">catch</span> err
0321        <span class="keyword">if</span> (strcmp(err.identifier,<span class="string">'MATLAB:nomem'</span>))
0322           msg = sprintf(<span class="string">'%s'</span>, <span class="keyword">...</span>
0323              <span class="string">'Matlab ran out of memory. Consider setting save_memory &gt; 0.\n'</span>, <span class="keyword">...</span>
0324              <span class="string">'See HELP MK_GRID_C2F for details.'</span>);
0325           error(<span class="string">'EIDORS:mk_grid_c2f:nomem'</span>,msg);
0326        <span class="keyword">else</span>
0327           rethrow(err);
0328        <span class="keyword">end</span>
0329     <span class="keyword">end</span>
0330     
0331     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Calculate intersection volumes...'</span>);
0332     <span class="comment">% sparse logical multiplication doesn't exist</span>
0333     vox2intpt1 = logical(m.vox2face*rec2intpt1)'; 
0334     tet2intpt1 = logical(fmdl.edge2elem'*tedge2intpt1)';
0335 
0336     tet2intpt2 = logical(fmdl.elem2face*tri2intpt2)';
0337     vox2intpt2 = logical(m.vox2edge*vedge2intpt2)';
0338 
0339     tet2intpt3 = logical(fmdl.edge2elem'*tedge2intpt3)';
0340     vox2intpt3 = logical(m.vox2edge*vedge2intpt3)';
0341     
0342     vox_todo = find(sum(vox2intTet,2)&gt;0);
0343     C = []; F = []; V = [];
0344     
0345     id = 0; lvox = length(vox_todo);
0346     mint = ceil(lvox/100);
0347     <span class="keyword">for</span> v = vox_todo'
0348         id = id+1;
0349         <span class="keyword">if</span> mod(id,mint)==0, <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(id/lvox); <span class="keyword">end</span>
0350         tet_todo = find(vox2intTet(v,:));
0351         common_intpts1 = bsxfun(@and,vox2intpt1(:,v), tet2intpt1(:,tet_todo));
0352         common_intpts2 = bsxfun(@and,vox2intpt2(:,v), tet2intpt2(:,tet_todo));
0353         common_intpts3 = bsxfun(@and,vox2intpt3(:,v), tet2intpt3(:,tet_todo));
0354         tet_nodes     = bsxfun(@and,fnode2vox(:,v), fmdl.node2elem(:,tet_todo));
0355         vox_nodes     = bsxfun(@and,vnode2tet(:,tet_todo), m.node2vox(:,v));
0356 
0357         C = [C; v*ones(numel(tet_todo),1)];
0358         F = [F; tet_todo'];
0359         last_v = numel(V);
0360         V = [V; zeros(numel(tet_todo),1)]; <span class="comment">% pre-allocate</span>
0361 
0362         <span class="keyword">for</span> t = 1:numel(tet_todo)
0363             pts = [ intpts1(common_intpts1(:,t),:); <span class="comment">% tet edge v. vox face</span>
0364                     intpts2(common_intpts2(:,t),:); <span class="comment">% vox edge v. tet face</span>
0365                     intpts3(common_intpts3(:,t),:); <span class="comment">% vox edge v. tet edge</span>
0366                     fmdl.nodes(tet_nodes(:,t),:);   <span class="comment">% tet node in vox</span>
0367                     rmdl.nodes(vox_nodes(:,t),:)];  <span class="comment">% vox node in tet</span>
0368             last_v = last_v + 1;
0369             ok = false;
0370             <span class="keyword">if</span> size(pts,1) &lt; 4 
0371               <span class="comment">% we should have enough confidence by now</span>
0372               <span class="comment">% unless the tolerances were specified weird</span>
0373               <span class="keyword">continue</span> 
0374             <span class="keyword">end</span>
0375             <span class="keyword">if</span> size(pts,1) &lt; 4 <span class="comment">% test if edge lies on the plane of the vox</span>
0376                 <span class="comment">% check for edges along the x y or z axis</span>
0377                 <span class="comment">% this includes coplanar faces</span>
0378                 E = fmdl.edges(fmdl.elem2edge(tet_todo(t),:),:);
0379                 P1 = fmdl.nodes(E(:,1),:);
0380                 P2 = fmdl.nodes(E(:,2),:);
0381                 <span class="comment">% this test is sensitive, but not specific</span>
0382                 <span class="comment">% it should also check if both pts come from the same edge and</span>
0383                 <span class="comment">% that edge fullfils the condition</span>
0384                 D = P1-P2;
0385                 ok = any(abs(D(:)) &lt;= eps); 
0386             <span class="keyword">end</span> 
0387             <span class="keyword">if</span> ok; <span class="keyword">continue</span>, <span class="keyword">end</span> <span class="comment">% otherwise convhulln will throw an error</span>
0388             <span class="keyword">try</span>
0389                 <span class="comment">% move points to origin (helps for small elements at</span>
0390                 <span class="comment">% large coordinates</span>
0391                 ctr = mean(pts);
0392                 pts = bsxfun(@minus,pts,ctr);
0393                 scale = max(abs(pts(:)));
0394                 <span class="keyword">if</span> scale == 0 <span class="comment">%happens when there's only one point</span>
0395                    <span class="keyword">continue</span>
0396                 <span class="keyword">end</span>
0397                 <span class="comment">% scale largest coordinate to 1 (helps with precision)</span>
0398                 pts = pts ./ scale;
0399                 <span class="comment">% force thorough search for initinal simplex and</span>
0400                 <span class="comment">% supress precision warnings</span>
0401                 [~, V(last_v)] = <a href="convhulln_clean.html" class="code" title="function [K,V] = convhulln_clean(pts,p);">convhulln_clean</a>(pts);
0402                 V(last_v) = V(last_v) * scale^3; <span class="comment">% undo scaling</span>
0403             <span class="keyword">catch</span> err
0404                 ok = false;
0405                 <span class="keyword">switch</span> err.identifier
0406                     <span class="keyword">case</span> {<span class="string">'MATLAB:qhullmx:DegenerateData'</span>}
0407                         <span class="comment">% if QHull is degenerate, then are is zero.</span>
0408                         ok = 1;
0409 
0410                     <span class="keyword">case</span> {<span class="string">'MATLAB:qhullmx:DegenerateData'</span>, <span class="string">'MATLAB:qhullmx:UndefinedError'</span>, <span class="keyword">...</span>
0411                             <span class="string">'MATLAB:cgprechecks:NotEnoughPts'</span>}
0412                         <span class="comment">% check for edges along the x y or z axis</span>
0413                         <span class="comment">% this includes coplanar faces</span>
0414                         E = fmdl.edges(fmdl.elem2edge(tet_todo(t),:),:);
0415                         P1 = fmdl.nodes(E(:,1),:);
0416                         P2 = fmdl.nodes(E(:,2),:);
0417                         <span class="comment">% this test is sensitive, but not specific</span>
0418                         <span class="comment">% it should also check if both pts come from the same edge and</span>
0419                         <span class="comment">% that edge fullfils the condition</span>
0420                         D = P1-P2;
0421                         ok = any(abs(D) &lt; 10*eps);
0422                         <span class="comment">% edge-edge intersections often appear to also</span>
0423                         <span class="comment">% cross faces, there doesn't seem to be a good</span>
0424                         <span class="comment">% specific way to catch that</span>
0425                         u = uniquetol(pts*scale,10*eps,<span class="string">'ByRows'</span>,true,<span class="string">'DataScale'</span>, 1);
0426                         ok = ok | size(u,1) &lt; 4;
0427                 <span class="keyword">end</span>
0428                 <span class="keyword">if</span> ~ok &amp; size(u,1) == 4
0429                         ok = ok | det([ones(4,1),u])&lt;eps;
0430                 <span class="keyword">end</span>
0431                 <span class="keyword">if</span> ~ok
0432                     <span class="keyword">if</span> DEBUG || <a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>(<span class="string">'query'</span>,<span class="string">'mk_grid_c2f:convhulln'</span>)
0433                         tet.nodes = fmdl.nodes;
0434                         vox.nodes = rmdl.nodes;
0435                         tet.type = <span class="string">'fwd_model'</span>;
0436                         vox.type = <span class="string">'fwd_model'</span>;
0437                         vox.elems = m.faces(logical(m.vox2face(v,:)),:);
0438                         vox.boundary = vox.elems;
0439                         tet.elems = fmdl.elems(tet_todo(t),:);
0440                         
0441                         clf
0442                         <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(vox)
0443                         hold on
0444                         h = <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(tet);
0445                         set(h,<span class="string">'EdgeColor'</span>,<span class="string">'b'</span>)
0446                         pts = bsxfun(@plus,pts*scale,ctr);
0447                         plot3(pts(:,1),pts(:,2),pts(:,3),<span class="string">'o'</span>);
0448 <span class="comment">%                         plot3(nt(:,1),nt(:,2),nt(:,3),'xr');</span>
0449 <span class="comment">%                         plot3(nv(:,1),nv(:,2),nv(:,3),'xb');</span>
0450                         hold off
0451                         axis auto
0452                         keyboard
0453                     <span class="keyword">else</span>
0454                         fprintf(<span class="string">'\n'</span>);
0455                         <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>([<span class="string">'convhulln has thrown an error. '</span> <span class="keyword">...</span>
0456                             <span class="string">'Enable eidors_debug on mk_grid_c2f:convhulln and re-run to see a debug plot'</span>],0);
0457                         rethrow(err);
0458                     <span class="keyword">end</span>
0459                 <span class="keyword">end</span>
0460             <span class="keyword">end</span>
0461         <span class="keyword">end</span>
0462     <span class="keyword">end</span>
0463     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(Inf);
0464     c2f = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(F,C,V,opt.nTet,opt.nVox);
0465     
0466     <span class="comment">% add vox contained in tet</span>
0467     c2f = c2f + bsxfun(@times, <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(vox_in_tet), m.volume)';
0468     
0469     <span class="comment">% normalize to tet volume</span>
0470     vol = <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(fmdl, <span class="string">'no_c2f'</span>);
0471     c2f = bsxfun(@rdivide,c2f,vol);
0472 
0473     <span class="comment">% add tets contained in vox</span>
0474 
0475     c2f = c2f + tet_in_vox;
0476 
0477 <span class="comment">%-------------------------------------------------------------------------%</span>
0478 <span class="comment">% Crop obviously non-overlapping parts of the models to limit computation</span>
0479 <a name="_sub4" href="#_subfunctions" class="code">function [fmdl, rmdl, opt, felem_idx] = crop_models(fmdl0,rmdl0,opt, relem_idx)</a>
0480    
0481    fmdl = fmdl0;
0482    rmdl = rmdl0;
0483    
0484    opt.nVox = opt.Xsz*opt.Ysz*opt.Zsz;
0485    idx = rmdl0.coarse2fine * relem_idx &gt; 0;
0486    rmdl.elems = rmdl0.elems(idx,:);
0487    [node_idx, m,n] = unique(rmdl.elems(:));
0488    rmdl.elems = reshape(n,size(rmdl.elems));
0489    rmdl.nodes = rmdl0.nodes(node_idx,:);
0490    
0491    fnode_above = fmdl0.nodes(:,3) &gt; opt.zvec(end);
0492    <span class="comment">% matlab is so stupid!</span>
0493    felem_above = all(reshape(fnode_above(fmdl0.elems), size(fmdl0.elems)),2);
0494    
0495    fnode_below = fmdl0.nodes(:,3) &lt; opt.zvec(1);
0496    felem_below = all(reshape(fnode_below(fmdl0.elems), size(fmdl0.elems)),2);
0497    
0498    felem_idx   = ~(felem_below | felem_above);
0499    fmdl.elems = fmdl0.elems(felem_idx,:);
0500    fnode_idx = unique(fmdl.elems(:));
0501    fnode_idx_map = zeros(size(fmdl0.nodes,1),1);
0502    fnode_idx_map(fnode_idx) = 1:length(fnode_idx);
0503    fmdl.elems = reshape(fnode_idx_map(fmdl.elems),size(fmdl.elems));
0504    fmdl.edges = reshape(fnode_idx_map(fmdl0.edges),size(fmdl0.edges));
0505    fmdl.nodes = fmdl0.nodes(fnode_idx,:);
0506    fmdl.node2elem = fmdl0.node2elem(fnode_idx,felem_idx);
0507    
0508    
0509    fface_idx = sum(fmdl0.elem2face(felem_idx,:),1)&gt;0;
0510    fmdl.elem2face = fmdl0.elem2face(felem_idx,fface_idx);
0511    felem_idx_map = zeros(size(felem_idx));
0512    felem_idx_map(felem_idx) = 1:nnz(felem_idx);
0513    felem_idx_map = [0; felem_idx_map];
0514    fmdl.face2elem = fmdl0.face2elem(fface_idx,:);
0515    fmdl.face2elem = reshape(felem_idx_map(fmdl.face2elem + 1),size(fmdl.face2elem));
0516    fmdl.normals = fmdl0.normals(fface_idx,:);
0517    fmdl.faces = fmdl0.faces(fface_idx,:);
0518    fmdl.faces = reshape(fnode_idx_map(fmdl.faces),size(fmdl.faces));
0519    
0520    fedge_idx = unique(fmdl0.elem2edge(felem_idx,:));
0521    fedge_idx_map = zeros(size(fmdl0.edges,1),1);
0522    fedge_idx_map(fedge_idx) = 1:length(fedge_idx);
0523    fmdl.elem2edge = fedge_idx_map(fmdl0.elem2edge(felem_idx,:));
0524    fmdl.edge2elem = fmdl0.edge2elem(fedge_idx,felem_idx);
0525    fmdl.edges = fmdl.edges(fedge_idx,:);
0526    
0527    opt.nTet = size(fmdl.elems,1);
0528 
0529 <span class="comment">%-------------------------------------------------------------------------%</span>
0530 <span class="comment">% Prepare matrices for the voxel model</span>
0531 <a name="_sub5" href="#_subfunctions" class="code">function fmdl = prepare_fmdl(fmdl)</a>
0532     fmopt.elem2edge = true;
0533     fmopt.edge2elem = true;
0534     fmopt.face2elem = true;
0535     fmopt.node2elem = true;
0536     fmopt.normals   = true;
0537     fmopt.linear_reorder = false; <span class="comment">% this is slow and not needed</span>
0538     ll = <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,1);
0539     fmdl = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(fmdl,fmopt);
0540     <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,ll);
0541     fmdl.node2elem = logical(fmdl.node2elem);
0542     nElem = size(fmdl.elems,1);
0543     nFace = size(fmdl.faces,1);
0544     fmdl.elem2face = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(repmat((1:nElem)',1,4),double(fmdl.elem2face),true,nElem,nFace);
0545 
0546 
0547 <span class="comment">%-------------------------------------------------------------------------%</span>
0548 <span class="comment">% Prepare matrices for the voxel model</span>
0549 <a name="_sub6" href="#_subfunctions" class="code">function m = prepare_vox_mdl(rmdl,opt)</a>
0550 
0551     DEBUG = <a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>(<span class="string">'query'</span>,<span class="string">'mk_grid_c2f'</span>);
0552 
0553     [voxels, m.node2vox] = <a href="#_sub11" class="code" title="subfunction [voxels, node2vox] = mk_voxels(opt)">mk_voxels</a>(opt);
0554     <span class="keyword">if</span> DEBUG || <a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>(<span class="string">'query'</span>,<span class="string">'mk_grid_c2f:mk_voxels'</span>)
0555         <a href="#_sub16" class="code" title="subfunction show_voxels(rmdl,voxels)">show_voxels</a>(rmdl,voxels); title(<span class="string">'mk\_voxels'</span>);
0556     <span class="keyword">end</span>
0557 
0558     m.faces = <a href="#_sub12" class="code" title="subfunction faces = mk_faces(voxels,opt)">mk_faces</a>(voxels,opt);
0559     <span class="keyword">if</span> DEBUG || <a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>(<span class="string">'query'</span>,<span class="string">'mk_grid_c2f:mk_faces'</span>)
0560         <a href="#_sub17" class="code" title="subfunction test_faces(rmdl, faces, opt)">test_faces</a>(rmdl,m.faces,opt); title(<span class="string">'mk\_faces'</span>);
0561     <span class="keyword">end</span>
0562 
0563     m.vox2face = <a href="#_sub14" class="code" title="subfunction vox2face = mk_vox2face(opt)">mk_vox2face</a>(opt);
0564     <span class="keyword">if</span> DEBUG || <a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>(<span class="string">'query'</span>,<span class="string">'mk_grid_c2f:mk_vox2face'</span>)
0565         <span class="comment">% the numbers shown are useless, just check if all faces are present</span>
0566         <a href="#_sub16" class="code" title="subfunction show_voxels(rmdl,voxels)">show_voxels</a>(rmdl,m.faces(any(m.vox2face),:));title(<span class="string">'mk\_vox2face'</span>);
0567     <span class="keyword">end</span>
0568     m.edges = <a href="#_sub13" class="code" title="subfunction edges = mk_edges(voxels, opt)">mk_edges</a>(voxels,opt);
0569 
0570     m.edge_length = rmdl.nodes(m.edges(:,1),:) - rmdl.nodes(m.edges(:,2),:);
0571     m.edge_length = sqrt(sum(m.edge_length.^2,2));
0572     
0573     [m.vox2edge, m.volume]= <a href="#_sub15" class="code" title="subfunction [vox2edge, vol] = mk_vox2edge(m,opt)">mk_vox2edge</a>(m,opt);
0574 
0575 
0576 <span class="comment">%-------------------------------------------------------------------------%</span>
0577 <span class="comment">% Assign each rmdl node to the tet it is in (nodes on tet faces are counted</span>
0578 <span class="comment">% mutltiple times)</span>
0579 <a name="_sub7" href="#_subfunctions" class="code">function rnode2tet = get_nodes_in_tets(fmdl,rmdl, opt)</a>
0580     
0581     [A,b] = <a href="tet_to_inequal.html" class="code" title="function [A,b]=tet_to_inequal(v,e)">tet_to_inequal</a>(fmdl.nodes,fmdl.elems);
0582     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(.01);
0583     <span class="comment">% This is split to decrease the memory footprint</span>
0584     rnode2tet = (bsxfun(@minus, A(1:4:<span class="keyword">end</span>,:)*rmdl.nodes',b(1:4:end)) &lt;= opt.tol_node2tet)';
0585     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(.21);
0586     <span class="keyword">for</span> i = 2:4 
0587         rnode2tet = rnode2tet &amp; (bsxfun(@minus, A(i:4:<span class="keyword">end</span>,:)*rmdl.nodes',b(i:4:end)) &lt;= opt.tol_node2tet)'; 
0588         <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(.21 + (i-1)*.23);
0589     <span class="keyword">end</span>
0590     
0591     <span class="comment">% exclude coinciding nodes</span>
0592     ex= bsxfun(@eq,rmdl.nodes(:,1),fmdl.nodes(:,1)') &amp; <span class="keyword">...</span>
0593         bsxfun(@eq,rmdl.nodes(:,2),fmdl.nodes(:,2)') &amp; <span class="keyword">...</span>
0594         bsxfun(@eq,rmdl.nodes(:,3),fmdl.nodes(:,3)');
0595     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(.94);
0596     rnode2tet(any(ex,2),:) = 0;
0597     <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(1);
0598     
0599 
0600 <span class="comment">%-------------------------------------------------------------------------%</span>
0601 <span class="comment">% Assign each fmdl node to the vox it is in (nodes on vox faces are counted</span>
0602 <span class="comment">% mutltiple times)</span>
0603 <a name="_sub8" href="#_subfunctions" class="code">function [insnode] = get_nodes_in_voxels(fmdl,rmdl)</a>
0604 
0605     E = reshape(rmdl.elems',4*6,[])';
0606     E = E(:,[1 2 3 4 8 12 16 23]);
0607 
0608     NE = size(E,1);
0609     xnodes = reshape(rmdl.nodes(E,1),NE,[]);
0610     ynodes = reshape(rmdl.nodes(E,2),NE,[]);
0611     znodes = reshape(rmdl.nodes(E,3),NE,[]);
0612     minx = min(xnodes,[],2);
0613     maxx = max(xnodes,[],2);
0614     miny = min(ynodes,[],2);
0615     maxy = max(ynodes,[],2);
0616     minz = min(znodes,[],2);
0617     maxz = max(znodes,[],2);
0618 
0619     leftof  = bsxfun(@lt, fmdl.nodes(:,1)+eps, minx');
0620     rightof = bsxfun(@gt, fmdl.nodes(:,1)-eps, maxx');
0621     infront = bsxfun(@lt, fmdl.nodes(:,2)+eps, miny');
0622     behind  = bsxfun(@gt, fmdl.nodes(:,2)-eps, maxy');
0623     below   = bsxfun(@lt, fmdl.nodes(:,3)+eps, minz');
0624     above   = bsxfun(@gt, fmdl.nodes(:,3)-eps, maxz');
0625 
0626     outnode = leftof | rightof | behind | infront | below | above;
0627     insnode = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(~outnode);
0628 
0629 <span class="comment">%-------------------------------------------------------------------------%</span>
0630 <span class="comment">% Calculate intersection points between vox faces and tet edges</span>
0631 <a name="_sub9" href="#_subfunctions" class="code">function [intpts, face2edge, face2intpt, edge2intpt] = get_voxel_intersection_points(fmdl,faces,opt)</a>
0632 edges = fmdl.edges;
0633 nodes = fmdl.nodes;
0634 dir   = nodes(edges(:,2),:) - nodes(edges(:,1),:);
0635 intpts = [];
0636 F = []; E = []; I = [];
0637 
0638 SZ = [opt.Xsz, opt.Ysz, opt.Zsz];
0639 VEC = {opt.xvec, opt.yvec, opt.zvec};
0640 <span class="comment">% show_voxels(rmdl, voxels(faces,:))</span>
0641 
0642 <span class="comment">%  mdl = rmdl;</span>
0643 <span class="comment">%  mdl.elems = voxels(faces,:);</span>
0644 <span class="comment">%  img = mk_image(mdl,1);</span>
0645 todo = sum(SZ)+3;
0646 id = 0;
0647 step = ceil(todo/100);
0648 
0649 <span class="keyword">for</span> d = 1:3
0650     <span class="keyword">for</span> x = 0:SZ(d)
0651         id = id+1;
0652         <span class="keyword">if</span> mod(id,step)==0, <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(id/todo); <span class="keyword">end</span>
0653         <span class="comment">% plane-edge intersection</span>
0654         t = (VEC{d}(x+1) - nodes(edges(:,1),d)) ./ dir(:,d);
0655         crossing = t&gt;0 &amp; t&lt;1;
0656         crossed  = find(crossing);
0657         <span class="keyword">if</span> isempty(crossed), <span class="keyword">continue</span>, <span class="keyword">end</span>;
0658         <span class="comment">% intersection points</span>
0659         tmp   = nodes(edges(crossing,1),:) + bsxfun(@times,t(crossing),dir(crossing,:));
0660         face_coord = zeros(length(crossed),3);
0661         rmv = false(length(crossed),1);
0662         <span class="keyword">for</span> i = 1:3
0663             <span class="keyword">if</span> i == d
0664                face_coord(:,i) = x+1;
0665             <span class="keyword">else</span>
0666                 face_coord(:,i) = sum(bsxfun(@times,diff(bsxfun(@lt, tmp(:,i), VEC{i}'),1,2),(1:SZ(i))),2);
0667                 rmv = rmv | face_coord(:,i) == 0;
0668             <span class="keyword">end</span>
0669         <span class="keyword">end</span>
0670         <span class="comment">% also reject intersections with voxel nodes and edges</span>
0671         same_x = any(bsxfun(@eq,tmp(:,1),opt.xvec'),2);
0672         same_y = any(bsxfun(@eq,tmp(:,2),opt.yvec'),2);
0673         same_z = any(bsxfun(@eq,tmp(:,3),opt.zvec'),2);
0674         rmv = rmv | (same_x + same_y + same_z) &gt; 1;
0675         <span class="keyword">if</span> nnz(rmv) == numel(rmv), <span class="keyword">continue</span>, <span class="keyword">end</span>
0676         tmp(rmv,:) = []; 
0677         face_coord(rmv,:) = [];
0678         crossed(rmv) = [];
0679         face_coord = face_coord - 1;
0680         face_idx = d + face_coord(:,1)*opt.xstep + face_coord(:,2)*opt.ystep + face_coord(:,3)*opt.zstep;
0681         I = [I; (1:size(tmp,1))' + size(I,1)];
0682         F = [F; face_idx];
0683         E = [E; crossed];
0684         intpts = [intpts; tmp];
0685 <span class="comment">%         unique(face_idx)</span>
0686 <span class="comment">%         img.elem_data(:) = 0;</span>
0687 <span class="comment">%         img.elem_data(unique(face_idx)) = 1;</span>
0688 <span class="comment">%         show_fem(img,[0 0 1]);</span>
0689         <span class="comment">%     hold on</span>
0690         <span class="comment">%     x1 =fmdl.nodes(fmdl.edges(crossing,1),1);</span>
0691         <span class="comment">%     x2 =fmdl.nodes(fmdl.edges(crossing,2),1);</span>
0692         <span class="comment">%     y1 =fmdl.nodes(fmdl.edges(crossing,1),2);</span>
0693         <span class="comment">%     y2 =fmdl.nodes(fmdl.edges(crossing,2),2);</span>
0694         <span class="comment">%     z1 =fmdl.nodes(fmdl.edges(crossing,1),3);</span>
0695         <span class="comment">%     z2 =fmdl.nodes(fmdl.edges(crossing,2),3);</span>
0696         <span class="comment">%     plot3([x1 x2]',[y1 y2]',[z1 z2]','b');</span>
0697         <span class="comment">%     plot3(intpts(:,1),intpts(:,2),intpts(:,3),'ro','MarkerFaceColor','r');</span>
0698         <span class="comment">%     hold off</span>
0699         <span class="comment">%     axis auto</span>
0700         <span class="comment">%     view(2)</span>
0701         <span class="comment">%     pause</span>
0702     <span class="keyword">end</span>
0703 <span class="keyword">end</span>
0704 face2edge = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(F,E,I,size(faces,1),size(edges,1));
0705 face2intpt = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(F,I,ones(size(I)),size(faces,1),size(I,1));
0706 edge2intpt  = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(E,I,ones(size(I)),size(edges,1),size(I,1));
0707 
0708 <span class="comment">%-------------------------------------------------------------------------%</span>
0709 <span class="comment">% Calculate intersection points between tet faces and vox edges</span>
0710 <a name="_sub10" href="#_subfunctions" class="code">function [intpts, tri2edge, tri2intpt, edge2intpt] = get_tet_intersection_points(fmdl,m,opt)</a>
0711     
0712     intpts = [];
0713     T = []; E = []; I = [];
0714     Xsz = opt.Xsz; Ysz = opt.Ysz; Zsz = opt.Zsz;
0715     SZ = [opt.Xsz, opt.Ysz, opt.Zsz];
0716     VEC = {opt.xvec, opt.yvec, opt.zvec};
0717     STEP(1) = opt.xstep; 
0718     STEP(2) = STEP(1)*(Xsz+1);
0719     STEP(3) = STEP(2)*(Ysz+1);
0720     
0721     d = sum(fmdl.normals .* fmdl.nodes(fmdl.faces(:,1),:),2);
0722 
0723     line_axis = [3 1 2];
0724     <span class="keyword">for</span> i = 1:3
0725         <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(i,3);
0726         <span class="comment">% define edge lines</span>
0727         idx = 1:3;
0728         op = line_axis(i);
0729         idx(op) = [];
0730         
0731         pts = [repmat(VEC{idx(1)},SZ(idx(2))+1,1) kron(VEC{idx(2)},ones(SZ(idx(1))+1,1)) ];
0732         pt_idx = uint32(repmat((0:SZ(idx(1)))',SZ(idx(2))+1,1)*STEP(idx(1)) <span class="keyword">...</span>
0733                 + kron((0:SZ(idx(2)))', ones(SZ(idx(1))+1,1))*STEP(idx(2)));
0734         
0735         <span class="comment">% project on faces</span>
0736         <span class="comment">% plane equation is ax+by+cz+d = 0, where d = -(ax0 + by0 + cz0)</span>
0737         z = repmat(d,1,size(pts,1));
0738         <span class="keyword">for</span> j = 1:2
0739             z = z - bsxfun(@times,fmdl.normals(:,idx(j)),pts(:,j)');
0740         <span class="keyword">end</span>
0741         z = z ./ repmat(fmdl.normals(:,op),1,size(pts,1));
0742         in = <a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>(pts,fmdl.faces,fmdl.nodes(:,idx),2*opt.tol_edge2tri)';
0743 
0744         
0745         <span class="comment">% reject voxel nodes</span>
0746         v = VEC{op}';
0747         in = in &amp; ~reshape(any(bsxfun(@eq,z(:),v),2),size(in));
0748         M = bsxfun(@lt, z(:),v);
0749         M = xor(M(:,1:end-1), M(:,2:end));
0750 <span class="comment">%       edge_num1= reshape(uint32(sum(bsxfun(@times,uint32(M),uint32(1:SZ(op))),2)), size(z));</span>
0751         edge_num = reshape(uint32(M*(1:SZ(op))'), size(z));
0752 <span class="comment">%       if ~(all(all(edge_num1==edge_num))); keyboard; end</span>
0753         in = in &amp; edge_num &gt; 0;
0754         <span class="keyword">if</span> nnz(in) == 0, <span class="keyword">continue</span>, <span class="keyword">end</span>
0755         edge_num(~in) = 0;
0756 
0757         edge_num(in) = (edge_num(in)-1) * STEP(op);
0758         edge_idx = edge_num + bsxfun(@times,uint32(full(in)), uint32(i) + pt_idx');
0759 
0760         [t, p] = find(in);
0761         tmp = zeros(length(p),3);
0762         tmp(:,idx) = pts(p,1:2);
0763         tmp(:,op) = z(in);
0764         
0765         I = [I; (1:size(tmp,1))' + size(I,1)];
0766         T = [T; t];
0767         E = [E; edge_idx(in)];
0768         intpts = [intpts; tmp];        
0769     <span class="keyword">end</span>
0770     
0771     E = double(E); <span class="comment">% keep sparse happy</span>
0772     tri2edge = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(T,E,I,size(fmdl.faces,1),size(m.edges,1));
0773     tri2intpt = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(T,I,ones(size(I)),size(fmdl.faces,1),size(I,1));
0774     edge2intpt  = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(E,I,ones(size(I)),size(m.edges,1),size(I,1));
0775 
0776    
0777 <span class="comment">%-------------------------------------------------------------------------%</span>
0778 <span class="comment">% Make voxels</span>
0779 <a name="_sub11" href="#_subfunctions" class="code">function [voxels, node2vox] = mk_voxels(opt)</a>
0780     Xsz = opt.Xsz; Ysz = opt.Ysz; Zsz = opt.Zsz;
0781     Xp = Xsz+1; Yp = Ysz+1; Zp = Zsz+1; <span class="comment">% number of planes</span>
0782 
0783     up = Xp*Yp;
0784     vox = [ 1       1+up    1+up+Xp     1+Xp;
0785             1       2       2+up        1+up;
0786             1       1+Xp    2+Xp        2;
0787             2       2+up    2+up+Xp     2+Xp;
0788             1+Xp    2+Xp    2+up+Xp     1+up+Xp;
0789             1+up    1+Xp+up 2+Xp+up     2+up];
0790 
0791     voxrow   = bsxfun(@plus, repmat(vox,     Xsz,1), kron(0:Xsz-1          ,ones(1,6))');
0792     voxplane = bsxfun(@plus, repmat(voxrow,  Ysz,1), kron(Xp*(0:Ysz-1) , ones(1, 6*Xsz))');
0793     voxels   = bsxfun(@plus, repmat(voxplane,Zsz,1), kron(up*(0:Zsz-1) , ones(1, 6*Xsz*Ysz))');
0794     nVox     = Xsz * Ysz * Zsz;
0795     node2vox = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(voxels(1:3:<span class="keyword">end</span>,:),kron((1:nVox)',ones(2,4)),1);
0796     
0797 <span class="comment">%-------------------------------------------------------------------------%</span>
0798 <span class="comment">% Make faces</span>
0799 <a name="_sub12" href="#_subfunctions" class="code">function faces = mk_faces(voxels,opt)</a>
0800     Xsz = opt.Xsz; Ysz = opt.Ysz; Zsz = opt.Zsz;
0801     
0802     facerow     = [nonzeros(bsxfun(@plus,(1:3)',0:6:(Xsz-1)*6)); (Xsz-1)*6+4];
0803     faceplane   = bsxfun(@plus,facerow,0:6*Xsz:6*Xsz*(Ysz-1));
0804     <span class="comment">% cap duplicates faces in order to preserve nice indexing</span>
0805     cap         = kron(ones(3,1),faceplane(2:3:<span class="keyword">end</span>,end)')+3;
0806     faceplane   = [faceplane,[ cap(:); cap(end)]];
0807     faces       = bsxfun(@plus, faceplane(:), 0:6*Xsz*Ysz:6*Xsz*Ysz*(Zsz-1));
0808     <span class="comment">% cap duplicates faces in order to preserve nice indexing</span>
0809     cap         = reshape(kron(ones(3,1), 3:3:3*Xsz*Ysz'),3*Xsz,[]);
0810     cap         = bsxfun(@plus, cap, 0:Ysz-1);
0811     cap(end+1,:)= cap(<span class="keyword">end</span>,:);
0812     faces       = [faces(:); faces(cap(:),end)+3];
0813     faces       = voxels(faces,:);
0814     
0815 <span class="comment">%-------------------------------------------------------------------------%</span>
0816 <span class="comment">% Make edges</span>
0817 <a name="_sub13" href="#_subfunctions" class="code">function edges = mk_edges(voxels, opt)</a>
0818     Xsz = opt.Xsz; Ysz = opt.Ysz; Zsz = opt.Zsz;
0819     
0820     edgerow     = voxels([nonzeros(bsxfun(@plus,(1:3)',0:6:(Xsz-1)*6)); (Xsz-1)*6+4],1:2);
0821     edgerow(end+1,:) = edgerow(<span class="keyword">end</span>,:);
0822     edgerow(end+1,:) = voxels((Xsz-1)*6+4, [1 4]);
0823     edgeplane = repmat(edgerow,Ysz+1,1) + kron((Xsz+1)*(0:Ysz)', ones(size(edgerow)));
0824     <span class="comment">% replace ficticious edges with repetitions;</span>
0825     edgeplane((size(edgerow,1)*Ysz +3):3:<span class="keyword">end</span>,:) = edgeplane((size(edgerow,1)*Ysz +2):3:<span class="keyword">end</span>,:);
0826 
0827     up = (Xsz+1)*(Ysz+1);
0828     edges = repmat(edgeplane,Zsz+1,1) + kron((0:Zsz)'*up, ones(size(edgeplane)));
0829     
0830     <span class="comment">% replace ficticious edges with repetitions;</span>
0831     start = (size(edgeplane,1)*Zsz);
0832     edges( (start +1):3:<span class="keyword">end</span>,:) = edges( (start +2):3:<span class="keyword">end</span>,:);
0833     start = (size(edgeplane,1)*Zsz) + 3*Xsz;
0834     step  = size(edgerow,1);
0835     edges( (start +1):step:<span class="keyword">end</span>,:) = edges( (start +3):step:<span class="keyword">end</span>,:);
0836     edges( (start +2):step:<span class="keyword">end</span>,:) = edges( (start +3):step:<span class="keyword">end</span>,:);
0837     edges( end-2:<span class="keyword">end</span>,:) = edges(end-5:end-3,:);
0838 
0839 <span class="comment">%-------------------------------------------------------------------------%</span>
0840 <span class="comment">% Make mapping between voxels and faces</span>
0841 <a name="_sub14" href="#_subfunctions" class="code">function vox2face = mk_vox2face(opt)</a>
0842     Xsz = opt.Xsz; Ysz = opt.Ysz; Zsz = opt.Zsz;
0843     xstep = opt.xstep; ystep = opt.ystep; zstep = opt.zstep;
0844     
0845     vox = [1 2 3 1+xstep 2+ystep 3+zstep];
0846     voxrow = bsxfun(@plus,(0:Xsz-1)'*xstep,vox)';
0847     voxplane = bsxfun(@plus,(0:Ysz-1)*ystep,voxrow(:));
0848     voxvol   = bsxfun(@plus,(0:Zsz-1)*zstep,voxplane(:));
0849     voxvol   = reshape(voxvol, 6, [])';
0850     I = kron((1:size(voxvol,1))',ones(1,6));
0851     nFaces  = Zsz*(Ysz+1)*(3*Xsz+1) + Ysz*(3*Xsz+1);
0852     nVox    = Xsz*Ysz*Zsz;
0853     vox2face = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(I,voxvol,ones(size(I)),nVox,nFaces);   
0854     
0855 <span class="comment">%-------------------------------------------------------------------------%</span>
0856 <span class="comment">% Make mapping between voxels and edges</span>
0857 <a name="_sub15" href="#_subfunctions" class="code">function [vox2edge, vol] = mk_vox2edge(m,opt)</a>
0858     Xsz = opt.Xsz; Ysz = opt.Ysz; Zsz = opt.Zsz;
0859     xstep = opt.xstep; ystep = xstep*(Xsz+1); zstep = ystep*(Ysz+1);
0860     
0861     vox = [1 2 3 1+xstep 3+xstep 1+ystep 2+ystep 1+ystep+xstep <span class="keyword">...</span>
0862            2+zstep 3+zstep 3+zstep+xstep 2+zstep+ystep];
0863     voxrow = bsxfun(@plus,(0:Xsz-1)'*xstep,vox)';
0864     voxplane = bsxfun(@plus,(0:Ysz-1)*ystep,voxrow(:));
0865     voxvol   = bsxfun(@plus,(0:Zsz-1)*zstep,voxplane(:));
0866     voxvol   = reshape(voxvol, 12, [])';
0867     I = kron((1:size(voxvol,1))',ones(1,12));
0868     nEdges  = 3*(Zsz+1)*(Ysz+1)*(Xsz+1);
0869     nVox    = Xsz*Ysz*Zsz;
0870     vox2edge = <a href="../../eidors/overloads/sparse/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(I,voxvol,ones(size(I)),nVox,nEdges);
0871     vol =      m.edge_length(voxvol(:,1)) <span class="keyword">...</span>
0872             .* m.edge_length(voxvol(:,2)) <span class="keyword">...</span>
0873             .* m.edge_length(voxvol(:,3));
0874     
0875     
0876 <span class="comment">%-------------------------------------------------------------------------%</span>
0877 <span class="comment">% Show voxels</span>
0878 <a name="_sub16" href="#_subfunctions" class="code">function show_voxels(rmdl,voxels)    </a>
0879     mdl=rmdl;
0880     mdl.elems = voxels;
0881     mdl.boundary = mdl.elems;
0882     clf
0883     <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(mdl,[0 0 1]);
0884 
0885 <span class="comment">%-------------------------------------------------------------------------%</span>
0886 <span class="comment">% Test indexing of faces on planes by showing random x, y and z plane</span>
0887 <a name="_sub17" href="#_subfunctions" class="code">function test_faces(rmdl, faces, opt)</a>
0888     mdl = rmdl;
0889     mdl.elems = faces;
0890     mdl.boundary = mdl.elems;
0891     img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(mdl,0);
0892     img.elem_data(opt.xplane + (randi(opt.Xsz+1)-1)*opt.xstep) = 1;
0893     img.elem_data(opt.yplane + (randi(opt.Ysz+1)-1)*opt.ystep) = 2;
0894     img.elem_data(opt.zplane + (randi(opt.Zsz+1)-1)*opt.zstep) = 3;
0895     <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img,[0 0 1]);
0896 
0897 <span class="comment">%-------------------------------------------------------------------------%</span>
0898 <span class="comment">% Center scale models</span>
0899 <a name="_sub18" href="#_subfunctions" class="code">function [fmdl,rmdl] = center_scale_models(fmdl,rmdl, opt)</a>
0900     <span class="comment">% ensure 3D</span>
0901     <span class="keyword">if</span> size(rmdl.nodes,2)==2;
0902        rmdl = <a href="#_sub19" class="code" title="subfunction rmdl = rmdl_3D(rmdl, fmdl)">rmdl_3D</a>(rmdl, fmdl);
0903     <span class="keyword">end</span>
0904     ctr = mean([min(rmdl.nodes);max(rmdl.nodes)]);
0905     rmdl.nodes = bsxfun(@minus,rmdl.nodes,ctr);
0906     fmdl.nodes = bsxfun(@minus,fmdl.nodes,ctr);
0907     <span class="keyword">if</span> isfield(opt,<span class="string">'do_not_scale'</span>) &amp;&amp; opt.do_not_scale    
0908         <span class="keyword">return</span>
0909     <span class="keyword">end</span>
0910     maxnode = min( max(abs(rmdl.nodes(:))), max(abs(fmdl.nodes(:))));
0911     scale = 1/maxnode;
0912     rmdl.nodes = scale*rmdl.nodes;
0913     fmdl.nodes = scale*fmdl.nodes;
0914     <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@ models scaled by %g'</span>, scale,2);
0915     
0916 
0917 <span class="comment">% Make a 3D grid from 2D model</span>
0918 <span class="comment">% where the max and min enclose fmdl</span>
0919 <a name="_sub19" href="#_subfunctions" class="code">function rmdl = rmdl_3D(rmdl, fmdl)</a>
0920    fzmax = max(fmdl.nodes(:,3));
0921    fzmin = min(fmdl.nodes(:,3));
0922    rm_nodes = rmdl.nodes;
0923    oo = 0*rm_nodes(:,1) + 1;
0924    N = <a href="num_nodes.html" class="code" title="function num = num_nodes( mdl );">num_nodes</a>(rmdl);
0925    <span class="comment">% nodes at top + bottom</span>
0926    rmdl.nodes = [ <span class="keyword">...</span>
0927       rmdl.nodes,oo*fzmin;
0928       rmdl.nodes,oo*fzmax];
0929    rme = [
0930       rmdl.elems(:,[1,2,3,1]) + [N,0,0,0];
0931       rmdl.elems(:,[1,2,3,2]) + [N,N,0,0];
0932       rmdl.elems(:,[1,2,3,3]) + [N,N,N,0]];
0933    <span class="comment">% put elem block together</span>
0934    rme = reshape(rme,[],3,4);
0935    rme = permute(rme,[2,1,3]);
0936    rmdl.elems = reshape(rme,[],4);
0937    rmdl.coarse2fine = kron( <span class="keyword">...</span>
0938         rmdl.coarse2fine,[1;1;1]);
0939    <span class="keyword">return</span>
0940 <span class="comment">% Test code to see block</span>
0941    x = ones(6,1);
0942    rmdl.boundary = <a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(rmdl);
0943    x(3) = 2;
0944    img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(rmdl,x);
0945    <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img);
0946        
0947 <span class="comment">%-------------------------------------------------------------------------%</span>
0948 <span class="comment">% Parse option struct</span>
0949  <a name="_sub20" href="#_subfunctions" class="code">function opt = parse_opts(fmdl,rmdl, opt)</a>
0950     opt.xvec = unique(rmdl.nodes(:,1));
0951     opt.yvec = unique(rmdl.nodes(:,2));
0952     opt.zvec = unique(rmdl.nodes(:,3));
0953     opt.Xsz  = numel(opt.xvec)-1;
0954     opt.Ysz  = numel(opt.yvec)-1;
0955     opt.Zsz  = numel(opt.zvec)-1;
0956     opt.xstep = 3;
0957     opt.ystep = opt.xstep*opt.Xsz+1;
0958     opt.zstep = opt.ystep*(opt.Ysz+1);
0959     xrow    = 1 + (0:opt.Ysz-1)*opt.ystep;
0960     opt.xplane  = bsxfun(@plus, (0:opt.Zsz-1)'*opt.zstep,xrow);
0961     yrow    = 2 + (0:opt.Xsz-1)*opt.xstep;
0962     opt.yplane  = bsxfun(@plus, (0:opt.Zsz-1)'*opt.zstep,yrow);
0963     zrow    = 3 + (0:opt.Xsz-1)*opt.xstep;
0964     opt.zplane  = bsxfun(@plus, (0:opt.Ysz-1)'*opt.ystep,zrow);
0965     opt.nVox = opt.Xsz*opt.Ysz*opt.Zsz;
0966     opt.nTet = size(fmdl.elems,1);
0967     
0968     <span class="keyword">if</span> ~isfield(opt, <span class="string">'tol_node2tet'</span>);
0969         opt.tol_node2tet = eps; <span class="comment">% * max(rmdl_rng,fmdl_rng)^3;</span>
0970     <span class="keyword">end</span>
0971     <span class="keyword">if</span> ~isfield(opt, <span class="string">'tol_edge2edge'</span>)
0972         opt.tol_edge2edge = 6*sqrt(3)*eps(min(max(abs(fmdl.nodes(:))),max(abs(rmdl.nodes(:)))));
0973     <span class="keyword">end</span>
0974     <span class="keyword">if</span> ~isfield(opt, <span class="string">'tol_edge2tri'</span>)
0975         opt.tol_edge2tri = eps; <span class="comment">%1e-10</span>
0976     <span class="keyword">end</span>
0977     <span class="keyword">if</span> ~isfield(opt, <span class="string">'save_memory'</span>)
0978        opt.save_memory = 0;
0979     <span class="keyword">end</span>
0980     <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@ node2tet  tolerance = %g'</span>, opt.tol_node2tet,3);
0981     <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@ edge2edge tolerance = %g'</span>, opt.tol_edge2edge,3);
0982     <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@ edge2tri  tolerance = %g'</span>, opt.tol_edge2tri,3);
0983 
0984 <span class="comment">%-------------------------------------------------------------------------%</span>
0985 <span class="comment">% fprintf wrapper to use eidors log_level</span>
0986 <a name="_sub21" href="#_subfunctions" class="code">function logmsg(varargin)</a>
0987     <span class="keyword">if</span> <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>) &gt;= 2
0988         fprintf(varargin{:});
0989     <span class="keyword">end</span>
0990     
0991    
0992     
0993 <span class="comment">%-------------------------------------------------------------------------%</span>
0994 <span class="comment">% Perfom unit tests</span>
0995 <a name="_sub22" href="#_subfunctions" class="code">function do_unit_test</a>
0996     <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(<span class="string">'save_memory'</span>,0); <a href="#_sub24" class="code" title="subfunction do_small_test">do_small_test</a>;
0997     <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(<span class="string">'save_memory'</span>,1); <a href="#_sub24" class="code" title="subfunction do_small_test">do_small_test</a>;
0998     <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(<span class="string">'save_memory'</span>,10); <a href="#_sub24" class="code" title="subfunction do_small_test">do_small_test</a>;
0999     clf
1000     <a href="#_sub23" class="code" title="subfunction do_case_tests">do_case_tests</a>;
1001     <span class="keyword">return</span> <span class="comment">% the tests below are more about performance than correctness</span>
1002     <a href="#_sub25" class="code" title="subfunction do_realistic_test">do_realistic_test</a>;
1003     <a href="#_sub26" class="code" title="subfunction do_edge2edge_timing_test">do_edge2edge_timing_test</a>;
1004     
1005 <span class="comment">%-------------------------------------------------------------------------%</span>
1006 <span class="comment">% Test individual intersections</span>
1007 <a name="_sub23" href="#_subfunctions" class="code">function do_case_tests</a>
1008     ll = <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>);
1009     <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,1);
1010     vox = <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>([],0:1,0:1,0:1);
1011     tet.type = <span class="string">'fwd_model'</span>;
1012     tet.elems = [1 2 3 4];
1013 
1014     X = 4; Y = 6;
1015     <span class="keyword">for</span> i = 1:30
1016         tet.nodes = [0 0 0; 0 1 0; 1 0 0; 0 0 1];
1017         fprintf(<span class="string">'%d\n'</span>,i);
1018         <span class="keyword">switch</span> i
1019             <span class="keyword">case</span> 1 <span class="comment">% nothing in common</span>
1020                 txt = <span class="string">'Nothing in common'</span>;
1021                 tet.nodes = tet.nodes + 2;
1022                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1023                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1024                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1025                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1026                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1027                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1028                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1029                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1030 
1031             <span class="keyword">case</span> 2 <span class="comment">% common node</span>
1032                 tet.nodes = tet.nodes + 1;
1033                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1034                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1035                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Comm node tedge2rec'</span>,size(intpts,1),0,0); <span class="comment">% nothing</span>
1036                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1037                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Comm node vedge2tri'</span>,size(intpts,1),0,0); <span class="comment">% nothing</span>
1038                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1039                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Comm node edge2edge'</span>,size(intpts,1),0,0); <span class="comment">% nothing</span>
1040                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1041                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Comm node tnode2vox'</span>,fnode2vox,[1;0;0;0],0); <span class="comment">% 1 point</span>
1042                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1043                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Comm node vnode2tet'</span>,nnz(rnode2tet),0,0);  <span class="comment">% nothing</span>
1044                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1045 
1046             <span class="keyword">case</span> 3 <span class="comment">% tet_edge v vox_node</span>
1047                 txt = <span class="string">'tet_edge v vox_node'</span>;
1048                 tet.nodes(:,1:2) = tet.nodes(:,1:2) - 0.5;
1049                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1050                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1051                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1052                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1053                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1054                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1055                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1056                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1057                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),0,0); <span class="comment">% nothing</span>
1058                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1059                 res = zeros(8,1); res(1) = 1;
1060                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,rnode2tet,res,0);  <span class="comment">% 1 point</span>
1061                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1062 
1063             <span class="keyword">case</span> 4 <span class="comment">% tet_edge v vox_edge</span>
1064                 txt = <span class="string">'tet_edge v vox_edge'</span>;
1065                 tet.nodes(:,1:2) = tet.nodes(:,1:2) - 0.5;
1066                 tet.nodes(:,3)   = tet.nodes(:,3)   + 0.5;
1067                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1068                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1069                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1070                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1071                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(unique(intpts,<span class="string">'rows'</span>),1),1,0); <span class="comment">% 1 point</span>
1072                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1073                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),1,0); <span class="comment">% 1 point</span>
1074                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1075                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),0,0); <span class="comment">% nothing</span>
1076                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1077                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),0,0); <span class="comment">% nothing</span>
1078                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1079 
1080             <span class="keyword">case</span> 5 <span class="comment">% tet_edge on vox_face</span>
1081                 txt = <span class="string">'tet_edge on vox_face'</span>;
1082                 tet.nodes(:,1:2) = tet.nodes(:,1:2) - 0.3;
1083                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1084                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1085                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1086                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1087                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(unique(intpts,<span class="string">'rows'</span>),1),3,0); <span class="comment">% 3 points</span>
1088                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1089                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),2,0); <span class="comment">% 2 points</span>
1090                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1091                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),0,0); <span class="comment">% nothing</span>
1092                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1093                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),1,0); <span class="comment">% 1 point</span>
1094                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1095 
1096             <span class="keyword">case</span> 6 
1097                 txt = <span class="string">'vox_node on tet_face'</span>;
1098                 tet.nodes(:,1:2) = tet.nodes(:,1:2) - 0.3;
1099                 tet.nodes(:,3)   = tet.nodes(:,3) -0.4;
1100                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1101                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1102                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1103                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1104                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1105                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1106                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1107                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1108                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),0,0); <span class="comment">% nothing</span>
1109                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1110                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),1,0); <span class="comment">% 1 point</span>
1111                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1112 
1113             <span class="keyword">case</span> 7
1114                 txt = <span class="string">'tet_node on vox_face'</span>;
1115                 tet.nodes(:,1) = tet.nodes(:,1) - 1;
1116                 tet.nodes(:,2:3)  = tet.nodes(:,2:3) + .5;
1117                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1118                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1119                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1120                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1121                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1122                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1123                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1124                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1125                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),1,0); <span class="comment">% 1 point</span>
1126                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1127                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),0,0); <span class="comment">% nothing</span>
1128                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1129 
1130 
1131             <span class="keyword">case</span> 8
1132                 txt = <span class="string">'tet_node on vox_edge'</span>;
1133                 tet.nodes(:,1) = tet.nodes(:,1) - 1;
1134                 tet.nodes(:,2)  = tet.nodes(:,2) + .5;
1135                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1136                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1137                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1138                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1139                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(uniquetol(intpts,eps,<span class="string">'ByRows'</span>,true),1),1,0); <span class="comment">% 1 point</span>
1140                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1141                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1142                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1143                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),1,0); <span class="comment">% 1 point</span>
1144                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1145                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),0,0); <span class="comment">% nothing</span>
1146                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1147 
1148             <span class="keyword">case</span> 9
1149                 txt = <span class="string">'all nodes common'</span>;
1150                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1151                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1152                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1153                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1154                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1155                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1156                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1157                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1158                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),4,0); <span class="comment">% 4 points</span>
1159                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1160                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),0,0); <span class="comment">% nothing</span>
1161                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1162 
1163             <span class="keyword">case</span> 10
1164                 txt = <span class="string">'tet in vox'</span>;
1165                 tet.nodes = .25 + .5*tet.nodes;
1166                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1167                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1168                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1169                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1170                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1171                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1172                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1173                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1174                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),4,0); <span class="comment">% 4 points</span>
1175                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1176                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),0,0); <span class="comment">% nothing</span>
1177                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1178                 c2f = <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1179                 max_vox = max(vox.nodes);
1180                 min_vox = min(vox.nodes);
1181                 edges = max_vox-min_vox;
1182                 vox_vol = edges(:,1) .* edges(:,2) .* edges(:,3);
1183                 tet_vol = <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(tet);
1184                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,c2f, 1, 0);
1185 
1186             <span class="keyword">case</span> 11
1187                 txt = <span class="string">'vox in tet'</span>;
1188                 tet.nodes =  4*tet.nodes - .25;
1189                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1190                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1191                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1192                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1193                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1194                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1195                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1196                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1197                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),0,0);  <span class="comment">% nothing</span>
1198                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1199                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),8,0); <span class="comment">% 8 points</span>
1200                 c2f = <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1201                 max_vox = max(vox.nodes);
1202                 min_vox = min(vox.nodes);
1203                 edges = max_vox-min_vox;
1204                 vox_vol = edges(:,1) .* edges(:,2) .* edges(:,3);
1205                 tet_vol = <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(tet);
1206                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,c2f, vox_vol / tet_vol, 0);
1207 
1208 
1209             <span class="keyword">case</span> 12 
1210                 txt = <span class="string">'tet_edge v. vox_face'</span>;
1211                 tet.nodes(:,1:2) = tet.nodes(:,1:2) - 0.3;
1212                 tet.nodes(:,3)   = tet.nodes(:,3) + .4;
1213                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1214                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1215                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),2,0); <span class="comment">% 2 points</span>
1216                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1217                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),2,0); <span class="comment">% 2 points</span>
1218                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1219                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1220                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1221                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),0,0); <span class="comment">% nothing</span>
1222                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1223                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),0,0); <span class="comment">% nothing</span>
1224                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1225 
1226 
1227             <span class="keyword">case</span> 13
1228                 txt = <span class="string">'everything'</span>;
1229                 tet.nodes = tet.nodes + 0.7;
1230                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1231                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1232                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),3,0); <span class="comment">% 3 points</span>
1233                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1234                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),3,0); <span class="comment">% 3 points</span>
1235                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1236                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1237                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1238                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),1,0); <span class="comment">% 1 point</span>
1239                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1240                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),1,0); <span class="comment">% 1 point</span>
1241                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1242 
1243                 <span class="comment">%------- degenerate cases-----------%</span>
1244             <span class="keyword">case</span> 14 <span class="comment">% common edge</span>
1245                 txt = <span class="string">'DG1: Common edge'</span>;
1246                 tet.nodes(:,1:2) = tet.nodes(:,1:2) + 1;
1247                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1248                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1249                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1250                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1251                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1252                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1253                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1254                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1255                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,fnode2vox,[1;0;0;1],0); <span class="comment">% 2 points</span>
1256                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1257                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),0,0);  <span class="comment">% nothing</span>
1258                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1259 
1260             <span class="keyword">case</span> 15 <span class="comment">% common edge</span>
1261                 txt = <span class="string">'DG2: Common edge'</span>;
1262                 tet.nodes(:,1:2) = tet.nodes(:,1:2) + 1;
1263                 tet.nodes(:,3) = tet.nodes(:,3) + 0.5;
1264                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1265                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1266                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1267                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1268                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(unique(intpts,<span class="string">'rows'</span>),1),1,1); <span class="comment">% 1</span>
1269                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1270                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1271                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1272                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),1,0); <span class="comment">% 1 point</span>
1273                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1274                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),1,0);  <span class="comment">% 1 point</span>
1275                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1276 
1277              <span class="keyword">case</span> 16 <span class="comment">% common edge</span>
1278                 txt = <span class="string">'DG3: Common edge'</span>;
1279                 tet.nodes(:,1:2) = tet.nodes(:,1:2) + 1;
1280                 z = tet.nodes(:,3) == 0;
1281                 tet.nodes(z,3) = -.5;
1282                 tet.nodes(~z,3) = 1.5;
1283                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1284                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1285                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1286                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1287                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1288                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1289                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1290                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1291                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),0,0); <span class="comment">% nothing</span>
1292                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1293                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),2,0);  <span class="comment">% 2 points</span>
1294                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1295 
1296             <span class="keyword">case</span> 17 <span class="comment">% edge on face</span>
1297                 txt = <span class="string">'DG4: edge on face'</span>;
1298                 tet.nodes = [0 0 0; 1 .5 0; 0 1 0; 1 .5 1];
1299                 tet.nodes(:,1) = tet.nodes(:,1) - 1;
1300                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1301                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1302                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1303                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1304                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(unique(intpts,<span class="string">'rows'</span>),1),2,0); <span class="comment">% 2</span>
1305                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1306                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1307                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1308                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),2,0); <span class="comment">% 2 points</span>
1309                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1310                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),0,0);  <span class="comment">% nothing</span>
1311                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1312 
1313             <span class="keyword">case</span> 18 <span class="comment">% edge2edge only</span>
1314                 txt = <span class="string">'DG5: edge2edge only'</span>;
1315                 tet.nodes = [0 0 0; 1 .5 0; 0 1 0; 1 .5 1];
1316                 tet.nodes(:,1) = tet.nodes(:,1) - 1;
1317                 z = tet.nodes(:,3) == 0;
1318                 tet.nodes(z,3) = -.5;
1319                 tet.nodes(~z,3) = 1.5;
1320                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1321                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1322                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1323                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1324                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(unique(intpts,<span class="string">'rows'</span>),1),2,0); <span class="comment">% 2 points</span>
1325                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1326                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),2,0); <span class="comment">% 2 points</span>
1327                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1328                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),0,0); <span class="comment">% nothing</span>
1329                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1330                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),0,0);  <span class="comment">% nothing</span>
1331                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1332 
1333             <span class="keyword">case</span> 19 <span class="comment">% edge on face</span>
1334                 txt = <span class="string">'DG6: edge on face'</span>;
1335                 tet.nodes = [0 0 0; 1 .5 0; 0 1 0; 1 .5 1];
1336                 tet.nodes(:,1) = tet.nodes(:,1) - 1;
1337                 tet.nodes(:,3) = tet.nodes(:,3) - .5;
1338                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1339                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1340                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1341                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1342                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(unique(intpts,<span class="string">'rows'</span>),1),1,0); <span class="comment">% 1 point</span>
1343                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1344                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),1,0); <span class="comment">% 1 point</span>
1345                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1346                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),1,0); <span class="comment">% 1 points</span>
1347                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1348                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),0,0);  <span class="comment">% nothing</span>
1349                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1350 
1351             <span class="keyword">case</span> 20 <span class="comment">%face on face</span>
1352                 txt = <span class="string">'DG7: face on face'</span>;
1353                 tet.nodes(:,1) = tet.nodes(:,1) + 1;
1354                 tet.nodes(:,2) = tet.nodes(:,2) + 0.5;
1355                 tet.nodes(:,3) = tet.nodes(:,3) + 0.5;
1356                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1357                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1358                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1359                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1360                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(uniquetol(intpts,2*eps,<span class="string">'ByRows'</span>,true),1),3,0); <span class="comment">% 3 points</span>
1361                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1362                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(unique(intpts,<span class="string">'rows'</span>),1),2,0); <span class="comment">% 2 unique points (these edges are counted 3 times, but vox2edge takes care of this)</span>
1363                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1364                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),1,0); <span class="comment">% 1 point</span>
1365                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1366                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),1,0);  <span class="comment">% 1 point</span>
1367                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1368 
1369            <span class="keyword">case</span> 21 <span class="comment">%face on face</span>
1370                 txt = <span class="string">'DG8: face on face'</span>;
1371                 tet.nodes(:,1) = tet.nodes(:,1) + 1;
1372                 tet.nodes(:,2) = tet.nodes(:,2) + 0.4;
1373                 tet.nodes(:,3) = tet.nodes(:,3) - 0.6;
1374                 subplot(X,Y,i), <a href="#_sub32" class="code" title="subfunction show_test(vox,tet)">show_test</a>(vox,tet);
1375                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub29" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)">test_rec_tedge_intersections</a>(vox,tet);
1376                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(intpts,1),0,0); <span class="comment">% nothing</span>
1377                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub30" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)">test_tet_vedge_intersections</a>(vox,tet);
1378                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(unique(intpts,<span class="string">'rows'</span>),1),2,0); <span class="comment">% 2 points</span>
1379                 [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(vox,tet);
1380                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,size(unique(intpts,<span class="string">'rows'</span>),1),2,0); <span class="comment">% 2 unique points (these edges are counted 3 times, but vox2edge takes care of this)</span>
1381                 [fnode2vox] = <a href="#_sub28" class="code" title="subfunction [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)">test_tnode_in_vox</a>(vox,tet);
1382                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(fnode2vox),1,0); <span class="comment">% 1 point</span>
1383                 rnode2tet = <a href="#_sub27" class="code" title="subfunction rnode2tet = test_vnode_in_tet(rmdl,fmdl)">test_vnode_in_tet</a>(vox,tet);
1384                 <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function res = unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(txt,nnz(rnode2tet),0,0);  <span class="comment">% nothing</span>
1385                 <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(tet,vox);
1386 
1387             <span class="keyword">otherwise</span>
1388                 <span class="keyword">break</span>;
1389         <span class="keyword">end</span>
1390     <span class="keyword">end</span>
1391     <a href="../../eidors/eidors_msg.html" class="code" title="function log_level = eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,ll);
1392 
1393 <a name="_sub24" href="#_subfunctions" class="code">function do_small_test</a>
1394    fmdl= <a href="../../eidors/meshing/netgen/ng_mk_cyl_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_cyl_models(cyl_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_cyl_models</a>([2,2,.1],[16,1],[.1,0,.025]);
1395    xvec = [-1.5:1:1.5];
1396    yvec = [-1.6:.8:1.6];
1397    zvec = -1:1:2;
1398    rmdl = <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>([],xvec,yvec,zvec);
1399 
1400    <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a> clear
1401    tic
1402    c2f_a = <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(fmdl, rmdl);
1403    toc
1404    <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a> clear
1405    tic
1406    opt.save_memory = 2;
1407    c2f_b = <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(fmdl, rmdl, opt);
1408    toc
1409    <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a> clear
1410    tic
1411    c2f_c = <a href="mk_approx_c2f.html" class="code" title="function [mapping, outside] = mk_approx_c2f( f_mdl, c_mdl );">mk_approx_c2f</a>(fmdl, rmdl);
1412    toc
1413    assert(any(c2f_a(:) ~= c2f_b(:)) == 0);
1414    <span class="comment">% the old function cannot be tested this way, it doesn't give the right</span>
1415    <span class="comment">% answer</span>
1416    <span class="comment">% assert(any(c2f_a(:) ~= c2f_c(:)) == 0);</span>
1417    
1418 <a name="_sub25" href="#_subfunctions" class="code">function do_realistic_test</a>
1419 fmdl= <a href="../../eidors/meshing/netgen/ng_mk_cyl_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_cyl_models(cyl_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_cyl_models</a>([2,2,.1],[16,1],[.1,0,.025]);
1420 xvec = [-1.5 -.5:.2:.5 1.5];
1421 yvec = [-1.6 -1:.2:1 1.6];
1422 zvec = 0:.25:2;
1423 rmdl = <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>([],xvec,yvec,zvec);
1424 
1425 tic
1426 opt.save_memory = 0;
1427 c2f_a = <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>(fmdl, rmdl,opt);
1428 t = toc;
1429 fprintf(<span class="string">'Analytic: t=%f s\n'</span>,t);
1430 
1431 tic
1432 c2f_n = <a href="mk_approx_c2f.html" class="code" title="function [mapping, outside] = mk_approx_c2f( f_mdl, c_mdl );">mk_approx_c2f</a>(fmdl,rmdl);
1433 t = toc;
1434 fprintf(<span class="string">'Approximate: t=%f s\n'</span>,t);
1435 
1436 
1437 tetvol = <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(fmdl);
1438 opt = <a href="#_sub20" class="code" title="subfunction opt = parse_opts(fmdl,rmdl, opt)">parse_opts</a>(fmdl,rmdl);
1439 m = <a href="#_sub6" class="code" title="subfunction m = prepare_vox_mdl(rmdl,opt)">prepare_vox_mdl</a>(rmdl,opt);
1440 
1441 
1442 f2c_a = bsxfun(@times, c2f_a, tetvol);
1443 f2c_a = bsxfun(@rdivide,f2c_a', m.volume); 
1444 img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(rmdl,0);
1445 img.elem_data = f2c_a*ones(size(fmdl.elems,1),1);
1446 subplot(132)
1447 <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img);
1448 
1449 f2c_n = bsxfun(@times, c2f_n, tetvol);
1450 f2c_n = bsxfun(@rdivide,f2c_n', m.volume); 
1451 img = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(rmdl,0);
1452 img.elem_data = f2c_n*ones(size(fmdl.elems,1),1);
1453 subplot(133)
1454 <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img);
1455 subplot(131);
1456 h = <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(fmdl);
1457 set(h,<span class="string">'LineWidth'</span>,0.1)
1458 hold on
1459 h = <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(rmdl);
1460 set(h,<span class="string">'EdgeColor'</span>,<span class="string">'b'</span>,<span class="string">'LineWidth'</span>,2);
1461 hold off
1462 
1463 <a name="_sub26" href="#_subfunctions" class="code">function do_edge2edge_timing_test</a>
1464     fmdl= <a href="../../eidors/meshing/netgen/ng_mk_cyl_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_cyl_models(cyl_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_cyl_models</a>([2,2],[8,1],[.15,0,.05]);
1465     xvec = linspace(-2,2,33);
1466     yvec = linspace(-2,2,33);
1467     zvec = 0:.5:2;
1468     rmdl = <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec, removefn);">mk_grid_model</a>([],xvec,yvec,zvec);
1469     tic
1470     <a href="#_sub31" class="code" title="subfunction [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)">test_tedge2vedge_intersections</a>(rmdl,fmdl);
1471     toc
1472     
1473 <a name="_sub27" href="#_subfunctions" class="code">function rnode2tet = test_vnode_in_tet(rmdl,fmdl)</a>
1474     opt  = <a href="#_sub20" class="code" title="subfunction opt = parse_opts(fmdl,rmdl, opt)">parse_opts</a>(fmdl,rmdl);
1475     fmdl = <a href="#_sub5" class="code" title="subfunction fmdl = prepare_fmdl(fmdl)">prepare_fmdl</a>(fmdl);
1476     rnode2tet = <a href="#_sub7" class="code" title="subfunction rnode2tet = get_nodes_in_tets(fmdl,rmdl, opt)">get_nodes_in_tets</a>(fmdl,rmdl, opt);
1477 
1478 <a name="_sub28" href="#_subfunctions" class="code">function [fnode2vox] = test_tnode_in_vox(rmdl,fmdl)</a>
1479     fmdl = <a href="#_sub5" class="code" title="subfunction fmdl = prepare_fmdl(fmdl)">prepare_fmdl</a>(fmdl);
1480     [fnode2vox] = <a href="#_sub8" class="code" title="subfunction [insnode] = get_nodes_in_voxels(fmdl,rmdl)">get_nodes_in_voxels</a>(fmdl,rmdl);
1481     
1482 <a name="_sub29" href="#_subfunctions" class="code">function [intpts, face2edge, face2intpt, edge2intpt] = test_rec_tedge_intersections(rmdl,fmdl)</a>
1483     opt = <a href="#_sub20" class="code" title="subfunction opt = parse_opts(fmdl,rmdl, opt)">parse_opts</a>(fmdl,rmdl);
1484     m = <a href="#_sub6" class="code" title="subfunction m = prepare_vox_mdl(rmdl,opt)">prepare_vox_mdl</a>(rmdl,opt);
1485     fmdl = <a href="#_sub5" class="code" title="subfunction fmdl = prepare_fmdl(fmdl)">prepare_fmdl</a>(fmdl);
1486     [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub9" class="code" title="subfunction [intpts, face2edge, face2intpt, edge2intpt] = get_voxel_intersection_points(fmdl,faces,opt)">get_voxel_intersection_points</a>(fmdl,m.faces,opt);
1487         
1488 <a name="_sub30" href="#_subfunctions" class="code">function [intpts, face2edge, face2intpt, edge2intpt] = test_tet_vedge_intersections(rmdl,fmdl)</a>
1489     opt = <a href="#_sub20" class="code" title="subfunction opt = parse_opts(fmdl,rmdl, opt)">parse_opts</a>(fmdl,rmdl);
1490     m = <a href="#_sub6" class="code" title="subfunction m = prepare_vox_mdl(rmdl,opt)">prepare_vox_mdl</a>(rmdl,opt);
1491     fmdl = <a href="#_sub5" class="code" title="subfunction fmdl = prepare_fmdl(fmdl)">prepare_fmdl</a>(fmdl);
1492     [intpts, face2edge, face2intpt, edge2intpt] = <a href="#_sub10" class="code" title="subfunction [intpts, tri2edge, tri2intpt, edge2intpt] = get_tet_intersection_points(fmdl,m,opt)">get_tet_intersection_points</a>(fmdl,m,opt);
1493     
1494 <a name="_sub31" href="#_subfunctions" class="code">function [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = test_tedge2vedge_intersections(rmdl,fmdl)</a>
1495     opt = <a href="#_sub20" class="code" title="subfunction opt = parse_opts(fmdl,rmdl, opt)">parse_opts</a>(fmdl,rmdl);
1496     m = <a href="#_sub6" class="code" title="subfunction m = prepare_vox_mdl(rmdl,opt)">prepare_vox_mdl</a>(rmdl,opt);
1497     fmdl = <a href="#_sub5" class="code" title="subfunction fmdl = prepare_fmdl(fmdl)">prepare_fmdl</a>(fmdl);
1498     [intpts, tedge2vedge, tedge2intpt, vedge2intpt] = <a href="find_edge2edge_intersections.html" class="code" title="function [pts,FE2CE,FE2pts,CE2pts] = find_edge2edge_intersections(FE,FN,CE,CN, epsilon)">find_edge2edge_intersections</a>(fmdl.edges,fmdl.nodes,m.edges,rmdl.nodes, opt.tol_node2tet);
1499 
1500 <a name="_sub32" href="#_subfunctions" class="code">function show_test(vox,tet)</a>
1501     <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(vox);
1502     hold on
1503     h = <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(tet);
1504     set(h, <span class="string">'EdgeColor'</span>,<span class="string">'b'</span>);
1505     hold off
1506     axis auto</pre></div>
<hr><address>Generated on Sun 29-Dec-2024 19:54:43 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>